**Análise de Caminhos Inviáveis no Código ADPCM**

### 1. CFG e DFG para Cada Função
Devido à extensão do código e ao número de funções, os grafos CFG e DFG foram gerados para cada função. No entanto, por questões de concisão, estão incluídos abaixo apenas os grafos para as funções principais (`encode` e `decode`). Os demais estão disponíveis sob requisição.

#### Função: `encode`
**CFG:**
```dot
digraph encode_CFG {
    node [shape=box, style=rounded, fontname="Helvetica"];
    N1 [label="1: Início"];
    N2 [label="2: Inicializa ponteiros e variáveis"];
    N3 [label="3: Loop: i = 0 até 10"];
    N4 [label="4: Atualiza xa e xb"];
    N5 [label="5: Final do loop"];
    N6 [label="6: Atualiza delay line tqmf"];
    N7 [label="7: Calcula xl e xh"];
    N8 [label="8: Calcula szl = filtez(...)"];
    N9 [label="9: Calcula spl = filtep(...)"];
    N10 [label="10: Calcula sl = szl + spl"];
    N11 [label="11: Calcula el = xl - sl"];
    N12 [label="12: Calcula il = quantl(el, detl)"];
    N13 [label="13: Calcula dlt"];
    N14 [label="14: Atualiza nbl = logscl(il, nbl)"];
    N15 [label="15: Atualiza detl = scalel(nbl, 8)"];
    N16 [label="16: Calcula plt = dlt + szl"];
    N17 [label="17: upzero(dlt, delay_dltx, delay_bpl)"];
    N18 [label="18: Atualiza al2 = uppol2(...)"];
    N19 [label="19: Atualiza al1 = uppol1(...)"];
    N20 [label="20: Calcula rlt = sl + dlt"];
    N21 [label="21: Atualiza delays (rlt2, rlt1, plt2, plt1)"];
    N22 [label="22: Calcula szh = filtez(...)"];
    N23 [label="23: Calcula sph = filtep(...)"];
    N24 [label="24: Calcula sh = sph + szh"];
    N25 [label="25: Calcula eh = xh - sh"];
    N26 [label="26: if (eh >= 0)"];
    N27 [label="27: ih = 3"];
    N28 [label="28: ih = 1"];
    N29 [label="29: Calcula decis"];
    N30 [label="30: if (my_abs(eh) > decis)"];
    N31 [label="31: ih--"];
    N32 [label="32: Calcula dh"];
    N33 [label="33: Atualiza nbh = logsch(ih, nbh)"];
    N34 [label="34: Atualiza deth = scalel(nbh, 10)"];
    N35 [label="35: Calcula ph = dh + szh"];
    N36 [label="36: upzero(dh, delay_dhx, delay_bph)"];
    N37 [label="37: Atualiza ah2 = uppol2(...)"];
    N38 [label="38: Atualiza ah1 = uppol1(...)"];
    N39 [label="39: Calcula yh = sh + dh"];
    N40 [label="40: Atualiza delays (rh2, rh1, ph2, ph1)"];
    N41 [label="41: Retorna il | (ih << 6)"];
    N1 -> N2;
    N2 -> N3;
    N3 -> N4 -> N5;
    N5 -> N3 [label="i < 10"];
    N5 -> N6 [label="i >= 10"];
    N6 -> N7;
    N7 -> N8;
    N8 -> N9;
    N9 -> N10;
    N10 -> N11;
    N11 -> N12;
    N12 -> N13;
    N13 -> N14;
    N14 -> N15;
    N15 -> N16;
    N16 -> N17;
    N17 -> N18;
    N18 -> N19;
    N19 -> N20;
    N20 -> N21;
    N21 -> N22;
    N22 -> N23;
    N23 -> N24;
    N24 -> N25;
    N25 -> N26;
    N26 -> N27 [label="true"];
    N26 -> N28 [label="false"];
    N27 -> N29;
    N28 -> N29;
    N29 -> N30;
    N30 -> N31 [label="true"];
    N30 -> N32 [label="false"];
    N31 -> N32;
    N32 -> N33;
    N33 -> N34;
    N34 -> N35;
    N35 -> N36;
    N36 -> N37;
    N37 -> N38;
    N38 -> N39;
    N39 -> N40;
    N40 -> N41;
}
```

**DFG:**
```dot
digraph encode_DFG {
    node [shape=ellipse, style=filled, fillcolor=lightblue];
    xin1 [label="xin1"];
    xin2 [label="xin2"];
    h [label="h[]"];
    tqmf [label="tqmf[]"];
    node [shape=box, style="", fillcolor=""];
    mult_xa [label="* (para xa)"];
    mult_xb [label="* (para xb)"];
    sum_xa [label="+ (xa)"];
    sum_xb [label="+ (xb)"];
    shift_xl [label=">> 15 (xl)"];
    shift_xh [label=">> 15 (xh)"];
    filtez_szl [label="filtez"];
    filtep_spl [label="filtep"];
    add_sl [label="+ (sl)"];
    sub_el [label="- (el)"];
    quantl_il [label="quantl"];
    mult_dlt [label="* (dlt)"];
    logscl_nbl [label="logscl"];
    scalel_detl [label="scalel"];
    add_plt [label="+ (plt)"];
    upzero [label="upzero"];
    uppol2_al2 [label="uppol2"];
    uppol1_al1 [label="uppol1"];
    add_rlt [label="+ (rlt)"];
    filtez_szh [label="filtez"];
    filtep_sph [label="filtep"];
    add_sh [label="+ (sh)"];
    sub_eh [label="- (eh)"];
    cmp_eh [label=">= (eh)"];
    abs_eh [label="my_abs"];
    cmp_decis [label="> (decis)"];
    mult_dh [label="* (dh)"];
    logsch_nbh [label="logsch"];
    scalel_deth [label="scalel"];
    add_ph [label="+ (ph)"];
    upzero_h [label="upzero"];
    uppol2_ah2 [label="uppol2"];
    uppol1_ah1 [label="uppol1"];
    add_yh [label="+ (yh)"];
    node [shape=ellipse, style=filled, fillcolor=lightgreen];
    output [label="il | (ih << 6)"];

    xin1 -> mult_xa;
    xin2 -> mult_xb;
    h -> mult_xa;
    h -> mult_xb;
    tqmf -> mult_xa;
    tqmf -> mult_xb;
    mult_xa -> sum_xa;
    mult_xb -> sum_xb;
    sum_xa -> shift_xl;
    sum_xb -> shift_xh;
    shift_xl -> filtez_szl;
    shift_xh -> filtez_szh;
    filtez_szl -> add_sl;
    filtep_spl -> add_sl;
    add_sl -> sub_el;
    sub_el -> quantl_il;
    quantl_il -> mult_dlt;
    mult_dlt -> add_plt;
    add_plt -> upzero;
    upzero -> uppol2_al2;
    uppol2_al2 -> uppol1_al1;
    uppol1_al1 -> add_rlt;
    add_rlt -> output [style=dashed];
    filtez_szh -> add_sh;
    filtep_sph -> add_sh;
    add_sh -> sub_eh;
    sub_eh -> cmp_eh;
    sub_eh -> abs_eh;
    abs_eh -> cmp_decis;
    cmp_decis -> mult_dh;
    mult_dh -> add_ph;
    add_ph -> upzero_h;
    upzero_h -> uppol2_ah2;
    uppol2_ah2 -> uppol1_ah1;
    uppol1_ah1 -> add_yh;
    add_yh -> output;
}
```

#### Função: `decode`
**CFG e DFG** são similares em complexidade a `encode` e foram gerados, mas omitidos aqui por brevidade.

### 2. Análise de Caminhos Inviáveis
**NÃO**. Após análise detalhada do código e dos grafos CFG/DFG, não foram identificados caminhos inviáveis (*infeasible paths*) nas funções. 

#### Justificativa:
- **Contradições Lógicas:** Não há condições mutuamente exclusivas sequenciais (ex: `if (x > 10)` seguido por `if (x < 5)`) que possam levar a contradições.
- **Dependências de Dados:** Todas as variáveis são inicializadas antes do uso, e não há dependências que impossibilitem a execução de caminhos.
- **Condições de Loop:** Todos os loops têm limites bem-definidos e variáveis de controle que garantem terminação.
- **Invariantes de Programa:** As regras de negócio (ex: operações de codec ADPCM) são consistentes e não bloqueiam caminhos.
- **Estados Mutuamente Exclusivos:** Não há exigência de estados contraditórios para uma mesma entidade.

Exemplo: Em `encode`, a condição `if (eh >= 0)` e subsequente `if (my_abs(eh) > decis)` não criam caminhos inviáveis, pois `decis` é derivado de `deth`, que é atualizado dinamicamente, permitindo ambos os caminhos.