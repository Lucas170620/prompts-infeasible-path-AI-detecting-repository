**Função:** `main`

**Grafo de Fluxo de Controle (CFG) em formato Graphviz:**
```dot
digraph main_CFG {
    node [shape=box];
    N1 [label="InitSeed();"];
    N2 [label="Test(Array);"];
    N3 [label="return 1;"];
    N1 -> N2 -> N3;
}
```

**Grafo de Fluxo de Dados (DFG) em formato Graphviz:**
```dot
digraph main_DFG {
    node [shape=ellipse];
    // Não há dependências de dados explícitas entre as instruções, pois as funções operam em variáveis globais.
    N1 [label="InitSeed"];
    N2 [label="Test"];
    // Chamadas de função sem passagem explícita de parâmetros (uso de globais).
}
```

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função `main` é sequencial, sem branches ou loops. Todas as instruções são executadas linearmente, não havendo contradições lógicas ou de dados.

---

**Função:** `Test`

**Grafo de Fluxo de Controle (CFG) em formato Graphviz:**
```dot
digraph Test_CFG {
    node [shape=box];
    N1 [label="Initialize(Array);"];
    N2 [label="StartTime = 1000.0;"];
    N3 [label="Sum(Array);"];
    N4 [label="StopTime = 1500.0;"];
    N5 [label="TotalTime = (StopTime - StartTime) / 1000.0;"];
    N6 [label="return 0;"];
    N1 -> N2 -> N3 -> N4 -> N5 -> N6;
}
```

**Grafo de Fluxo de Dados (DFG) em formato Graphviz:**
```dot
digraph Test_DFG {
    node [shape=ellipse];
    StartTime [label="StartTime"];
    StopTime [label="StopTime"];
    TotalTime [label="TotalTime"];
    node [shape=box];
    AssignStart [label="="];
    AssignStop [label="="];
    ComputeTotal [label="(/ (- StopTime StartTime) 1000.0)"];
    AssignStart -> StartTime;
    AssignStop -> StopTime;
    StartTime -> ComputeTotal;
    StopTime -> ComputeTotal;
    ComputeTotal -> TotalTime;
}
```

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função `Test` é puramente sequencial, sem branches ou loops. Não há condições ou dependências de dados que possam levar a caminhos inviáveis.

---

**Função:** `Initialize`

**Grafo de Fluxo de Controle (CFG) em formato Graphviz:**
```dot
digraph Initialize_CFG {
    node [shape=box];
    N1 [label="OuterIndex = 0"];
    N2 [label="OuterIndex < MAXSIZE?"];
    N3 [label="InnerIndex = 0"];
    N4 [label="InnerIndex < MAXSIZE?"];
    N5 [label="Array[OuterIndex][InnerIndex] = RandomInteger()"];
    N6 [label="InnerIndex++"];
    N7 [label="OuterIndex++"];
    N8 [label="return 0;"];
    N1 -> N2;
    N2 -> N3 [label="true"];
    N2 -> N8 [label="false"];
    N3 -> N4;
    N4 -> N5 [label="true"];
    N4 -> N7 [label="false"];
    N5 -> N6;
    N6 -> N4;
    N7 -> N2;
}
```

**Grafo de Fluxo de Dados (DFG) em formato Graphviz:**
```dot
digraph Initialize_DFG {
    node [shape=ellipse];
    OuterIndex [label="OuterIndex"];
    InnerIndex [label="InnerIndex"];
    Array [label="Array"];
    node [shape=box];
    AssignOuter [label="="];
    AssignInner [label="="];
    AssignArray [label="="];
    IncInner [label="++"];
    IncOuter [label="++"];
    AssignOuter -> OuterIndex;
    AssignInner -> InnerIndex;
    OuterIndex -> AssignArray;
    InnerIndex -> AssignArray;
    AssignArray -> Array;
    IncInner -> InnerIndex;
    IncOuter -> OuterIndex;
}
```

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função `Initialize` contém loops aninhados, mas não há condições internas que possam criar contradições. Todos os caminhos são viáveis, pois os loops são executados um número fixo de vezes (MAXSIZE^2).

---

**Função:** `InitSeed`

**Grafo de Fluxo de Controle (CFG) em formato Graphviz:**
```dot
digraph InitSeed_CFG {
    node [shape=box];
    N1 [label="Seed = 0"];
    N2 [label="return 0;"];
    N1 -> N2;
}
```

**Grafo de Fluxo de Dados (DFG) em formato Graphviz:**
```dot
digraph InitSeed_DFG {
    node [shape=ellipse];
    Seed [label="Seed"];
    node [shape=box];
    AssignSeed [label="="];
    AssignSeed -> Seed;
}
```

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função `InitSeed` é sequencial e não possui branches. Não há caminhos inviáveis.

---

**Função:** `Sum`

**Grafo de Fluxo de Controle (CFG) em formato Graphviz:**
```dot
digraph Sum_CFG {
    node [shape=box];
    N1 [label="Ptotal = 0; Ntotal = 0; Pcnt = 0; Ncnt = 0;"];
    N2 [label="Outer = 0"];
    N3 [label="Outer < MAXSIZE?"];
    N4 [label="Inner = 0"];
    N5 [label="Inner < MAXSIZE?"];
    N6 [label="Array[Outer][Inner] < 0?"];
    N7 [label="Ptotal += Array[Outer][Inner]; Pcnt++;"];
    N8 [label="Ntotal += Array[Outer][Inner]; Ncnt++;"];
    N9 [label="Inner++"];
    N10 [label="Outer++"];
    N11 [label="Postotal = Ptotal; Poscnt = Pcnt; Negtotal = Ntotal; Negcnt = Ncnt;"];
    N1 -> N2;
    N2 -> N3;
    N3 -> N4 [label="true"];
    N3 -> N11 [label="false"];
    N4 -> N5;
    N5 -> N6 [label="true"];
    N5 -> N10 [label="false"];
    N6 -> N7 [label="true"];
    N6 -> N8 [label="false"];
    N7 -> N9;
    N8 -> N9;
    N9 -> N5;
    N10 -> N3;
}
```

**Grafo de Fluxo de Dados (DFG) em formato Graphviz:**
```dot
digraph Sum_DFG {
    node [shape=ellipse];
    Ptotal [label="Ptotal"];
    Ntotal [label="Ntotal"];
    Pcnt [label="Pcnt"];
    Ncnt [label="Ncnt"];
    Array [label="Array"];
    Postotal [label="Postotal"];
    Poscnt [label="Poscnt"];
    Negtotal [label="Negtotal"];
    Negcnt [label="Negcnt"];
    node [shape=box];
    InitVars [label="Initialize Ptotal, Ntotal, Pcnt, Ncnt"];
    UpdatePtotal [label="+="];
    UpdateNtotal [label="+="];
    IncPcnt [label="++"];
    IncNcnt [label="++"];
    AssignPostotal [label="="];
    AssignPoscnt [label="="];
    AssignNegtotal [label="="];
    AssignNegcnt [label="="];
    InitVars -> Ptotal;
    InitVars -> Ntotal;
    InitVars -> Pcnt;
    InitVars -> Ncnt;
    Array -> UpdatePtotal;
    Array -> UpdateNtotal;
    UpdatePtotal -> Ptotal;
    UpdateNtotal -> Ntotal;
    IncPcnt -> Pcnt;
    IncNcnt -> Ncnt;
    Ptotal -> AssignPostotal;
    Pcnt -> AssignPoscnt;
    Ntotal -> AssignNegtotal;
    Ncnt -> AssignNegcnt;
    AssignPostotal -> Postotal;
    AssignPoscnt -> Poscnt;
    AssignNegtotal -> Negtotal;
    AssignNegcnt -> Negcnt;
}
```

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `1`

**Justificativa:** A função `Sum` contém um branch condicional (`Array[Outer][Inner] < 0`). No entanto, a função `RandomInteger` (usada para inicializar `Array`) sempre retorna valores não negativos (0 a 8094), tornando a condição `Array[Outer][Inner] < 0` sempre falsa. Isso significa que o branch `true` (N7) é inviável para todos os elementos do array. Assim, há **1 caminho inviável** correspondente à execução do branch `true` em qualquer iteração. O branch `false` (N8) é sempre executado, tornando os outros caminhos viáveis.

---

**Função:** `RandomInteger`

**Grafo de Fluxo de Controle (CFG) em formato Graphviz:**
```dot
digraph RandomInteger_CFG {
    node [shape=box];
    N1 [label="Seed = ((Seed * 133) + 81) % 8095"];
    N2 [label="return Seed;"];
    N1 -> N2;
}
```

**Grafo de Fluxo de Dados (DFG) em formato Graphviz:**
```dot
digraph RandomInteger_DFG {
    node [shape=ellipse];
    Seed [label="Seed"];
    node [shape=box];
    ComputeSeed [label="= ((Seed * 133) + 81) % 8095"];
    ComputeSeed -> Seed;
}
```

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função `RandomInteger` é sequencial e não possui branches. Não há caminhos inviáveis.