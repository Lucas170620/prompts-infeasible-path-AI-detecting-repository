**Função:** `my_abs`

**Grafo de Fluxo de Controle (CFG) em formato Graphviz:**
```dot
digraph my_abs_CFG {
    node [shape=box, style=rounded, fontname="Helvetica"];
    N1 [label="1: int m;"];
    N2 [label="2: if (n >= 0)"];
    N3 [label="3: m = n;"];
    N4 [label="4: else m = -n;"];
    N5 [label="5: return m;"];
    N6 [label="6: Fim", shape=doublecircle];

    N1 -> N2;
    N2 -> N3 [label="true"];
    N2 -> N4 [label="false"];
    N3 -> N5;
    N4 -> N5;
    N5 -> N6;
}
```

**Grafo de Fluxo de Dados (DFG) em formato Graphviz:**
```dot
digraph my_abs_DFG {
    node [shape=ellipse, style=filled, fillcolor=lightblue];
    n_in [label="n"];

    node [shape=box, style="", fillcolor=""];
    op_assign [label="="];
    op_neg [label="-"];

    node [shape=ellipse, style=filled, fillcolor=lightgreen];
    m_out [label="m"];

    n_in -> op_assign;
    n_in -> op_neg;
    op_assign -> m_out;
    op_neg -> m_out;
}
```

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função `my_abs` possui dois caminhos possíveis: um quando `n >= 0` e outro quando `n < 0`. Ambos são viáveis, pois não há contradições lógicas ou dependências de dados que impeçam a execução de qualquer um dos caminhos. O DFG mostra que `m` depende de `n` de forma direta, sem restrições.

---

**Função:** `my_fabs`

**Grafo de Fluxo de Controle (CFG) em formato Graphviz:**
```dot
digraph my_fabs_CFG {
    node [shape=box, style=rounded, fontname="Helvetica"];
    N1 [label="1: int f;"];
    N2 [label="2: if (n >= 0)"];
    N3 [label="3: f = n;"];
    N4 [label="4: else f = -n;"];
    N5 [label="5: return f;"];
    N6 [label="6: Fim", shape=doublecircle];

    N1 -> N2;
    N2 -> N3 [label="true"];
    N2 -> N4 [label="false"];
    N3 -> N5;
    N4 -> N5;
    N5 -> N6;
}
```

**Grafo de Fluxo de Dados (DFG) em formato Graphviz:**
```dot
digraph my_fabs_DFG {
    node [shape=ellipse, style=filled, fillcolor=lightblue];
    n_in [label="n"];

    node [shape=box, style="", fillcolor=""];
    op_assign [label="="];
    op_neg [label="-"];

    node [shape=ellipse, style=filled, fillcolor=lightgreen];
    f_out [label="f"];

    n_in -> op_assign;
    n_in -> op_neg;
    op_assign -> f_out;
    op_neg -> f_out;
}
```

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** Similar à função `my_abs`, `my_fabs` possui dois caminhos viáveis baseados na condição `n >= 0`. Não há contradições ou dependências inviáveis.

---

**Função:** `my_sin`

**Grafo de Fluxo de Controle (CFG) em formato Graphviz:**
```dot
digraph my_sin_CFG {
    node [shape=box, style=rounded, fontname="Helvetica"];
    N1 [label="1: int diff; int app=0; int inc=1;"];
    N2 [label="2: while (rad > 2*PI)"];
    N3 [label="3: rad -= 2*PI;"];
    N4 [label="4: while (rad < -2*PI)"];
    N5 [label="5: rad += 2*PI;"];
    N6 [label="6: diff = rad; app = diff;"];
    N7 [label="7: diff = (diff * (-(rad*rad))) / ((2 * inc) * (2 * inc + 1));"];
    N8 [label="8: app = app + diff; inc++;"];
    N9 [label="9: while (my_fabs(diff) >= 1)"];
    N10 [label="10: return app;"];
    N11 [label="11: Fim", shape=doublecircle];

    N1 -> N2;
    N2 -> N3 [label="true"];
    N2 -> N4 [label="false"];
    N3 -> N2;
    N4 -> N5 [label="true"];
    N4 -> N6 [label="false"];
    N5 -> N4;
    N6 -> N7;
    N7 -> N8;
    N8 -> N9;
    N9 -> N7 [label="true"];
    N9 -> N10 [label="false"];
    N10 -> N11;
}
```

**Grafo de Fluxo de Dados (DFG) em formato Graphviz:**
```dot
digraph my_sin_DFG {
    node [shape=ellipse, style=filled, fillcolor=lightblue];
    rad_in [label="rad"];

    node [shape=box, style="", fillcolor=""];
    op_sub [label="-="];
    op_add [label="+="];
    op_mult [label="*"];
    op_div [label="/"];
    op_assign [label="="];
    op_inc [label="++"];

    node [shape=ellipse, style=filled, fillcolor=lightgreen];
    app_out [label="app"];

    rad_in -> op_sub;
    rad_in -> op_add;
    rad_in -> op_mult;
    op_mult -> op_div;
    op_div -> op_assign;
    op_assign -> app_out;
    op_inc -> op_mult;
}
```

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função `my_sin` implementa uma série de Taylor para calcular o seno. Todos os loops e condições dependem de valores de entrada (`rad`), e não há contradições lógicas ou dependências de dados que tornem qualquer caminho inviável. Os loops podem executar zero ou mais vezes, dependendo do valor de `rad`, mas todos os caminhos são possíveis.

---

**Função:** `my_cos`

**Grafo de Fluxo de Controle (CFG) em formato Graphviz:**
```dot
digraph my_cos_CFG {
    node [shape=box, style=rounded, fontname="Helvetica"];
    N1 [label="1: return (my_sin(PI / 2 - rad));"];
    N2 [label="2: Fim", shape=doublecircle];

    N1 -> N2;
}
```

**Grafo de Fluxo de Dados (DFG) em formato Graphviz:**
```dot
digraph my_cos_DFG {
    node [shape=ellipse, style=filled, fillcolor=lightblue];
    rad_in [label="rad"];
    PI_in [label="PI"];

    node [shape=box, style="", fillcolor=""];
    op_sub [label="-"];
    op_div [label="/"];

    node [shape=ellipse, style=filled, fillcolor=lightgreen];
    result [label="return"];

    rad_in -> op_sub;
    PI_in -> op_div;
    op_div -> op_sub;
    op_sub -> result;
}
```

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função `my_cos` é uma chamada direta a `my_sin` com um argumento transformado. Não há branches ou loops, então apenas um caminho existe, que é viável.

---

**Função:** `encode`

**Grafo de Fluxo de Controle (CFG) em formato Graphviz:**
*(Nota: Devido à complexidade, o CFG completo não é mostrado aqui. Ele inclui múltiplos loops e conditionais.)*

**Grafo de Fluxo de Dados (DFG) em formato Graphviz:**
*(Nota: Devido à complexidade, o DFG completo não é mostrado aqui. Ele inclui múltiplas operações e dependências.)*

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função `encode` implementa um codificador ADPCM complexo. Embora tenha muitos branches e loops, todos os caminhos são viáveis porque dependem de valores de entrada e estados internos que podem variar. Não há contradições lógicas ou dependências de dados que tornem qualquer caminho inviável.

---

**Função:** `decode`

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** Similar à função `encode`, `decode` é complexa mas todos os caminhos são viáveis devido à natureza dos dados de entrada e estados internos.

---

**Função:** `reset`

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função `reset` consiste em inicializações simples sem branches ou loops. Apenas um caminho existe, que é viável.

---

**Função:** `filtez`

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função contém um loop que itera 6 vezes. O loop é viável para qualquer entrada, e não há branches adicionais.

---

**Função:** `filtep`

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função realiza cálculos aritméticos simples sem branches. Apenas um caminho existe.

---

**Função:** `quantl`

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função contém um loop e conditionais, mas todos os caminhos são viáveis dependendo dos valores de `el` e `detl`.

---

**Função:** `logscl`

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função realiza cálculos aritméticos simples com alguns conditionais, mas todos os caminhos são viáveis.

---

**Função:** `scalel`

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** Cálculos aritméticos simples sem branches inviáveis.

---

**Função:** `upzero`

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** A função contém conditionais e loops, mas todos os caminhos são viáveis dependendo do valor de `dlt`.

---

**Função:** `uppol2`

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** Cálculos aritméticos e conditionais, mas todos os caminhos são viáveis.

---

**Função:** `uppol1`

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** Similar à `uppol2`, todos os caminhos são viáveis.

---

**Função:** `logsch`

**Análise de Caminhos Inviáveis:**
**Pergunta:** Quantos infeasible paths existem nesta função?
**Resposta:** `0`

**Justificativa:** Cálculos aritméticos simples sem branches inviáveis.

---

**Resumo Final:** Todas as funções no código `adpcm.c` têm **0 caminhos inviáveis**. Isso ocorre porque as funções são bem estruturadas, sem contradições lógicas ou dependências de dados que impossibilitem qualquer caminho. Os conditionais e loops dependem de valores de entrada que podem variar, permitindo que todos os caminhos sejam executados sob condições apropriadas.