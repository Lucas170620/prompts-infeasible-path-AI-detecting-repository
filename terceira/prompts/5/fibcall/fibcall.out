**CFG and DFG for `fib` function:**

```dot
digraph fib_CFG {
    node [shape=box, style=rounded, fontname="Helvetica"];
    N1 [label="1: int i, Fnew, Fold, temp, ans;"];
    N2 [label="2: Fnew = 1; Fold = 0;"];
    N3 [label="3: i = 2;"];
    N4 [label="4: condition: i <= 30 && i <= n"];
    N5 [label="5: temp = Fnew; Fnew = Fnew + Fold; Fold = temp;"];
    N6 [label="6: i++"];
    N7 [label="7: ans = Fnew;"];
    N8 [label="8: return ans;"];
    N9 [label="Exit", shape=doublecircle];
    N1 -> N2;
    N2 -> N3;
    N3 -> N4;
    N4 -> N5 [label="true"];
    N4 -> N7 [label="false"];
    N5 -> N6;
    N6 -> N4;
    N7 -> N8;
    N8 -> N9;
}
```

```dot
digraph fib_DFG {
    node [shape=ellipse, style=filled, fillcolor=lightblue];
    n [label="n"];
    const_1 [label="1"];
    const_0 [label="0"];
    const_2 [label="2"];
    node [shape=box, style="", fillcolor=""];
    op_init_fnew [label="="];
    op_init_fold [label="="];
    op_init_i [label="="];
    op_cond [label="&&"];
    op_lt30 [label="<="];
    op_ltn [label="<="];
    op_temp [label="="];
    op_add [label="+"];
    op_assign_fold [label="="];
    op_inc_i [label="++"];
    op_ans [label="="];
    node [shape=ellipse, style=filled, fillcolor=lightgreen];
    ans_out [label="ans"];
    const_1 -> op_init_fnew;
    op_init_fnew -> Fnew;
    const_0 -> op_init_fold;
    op_init_fold -> Fold;
    const_2 -> op_init_i;
    op_init_i -> i;
    i -> op_lt30;
    const_30 -> op_lt30 [style=dotted]; // 30 is a constant
    op_lt30 -> op_cond;
    i -> op_ltn;
    n -> op_ltn;
    op_ltn -> op_cond;
    op_cond -> loop_body [style=invis]; // Control dependency, not data
    Fnew -> op_temp;
    op_temp -> temp;
    Fnew -> op_add;
    Fold -> op_add;
    op_add -> Fnew;
    temp -> op_assign_fold;
    op_assign_fold -> Fold;
    i -> op_inc_i;
    op_inc_i -> i;
    Fnew -> op_ans;
    op_ans -> ans_out;
}
```

**CFG and DFG for `main` function:**

```dot
digraph main_CFG {
    node [shape=box, style=rounded, fontname="Helvetica"];
    N1 [label="1: int a;"];
    N2 [label="2: a = 30;"];
    N3 [label="3: fib(a);"];
    N4 [label="4: return a;"];
    N5 [label="Exit", shape=doublecircle];
    N1 -> N2;
    N2 -> N3;
    N3 -> N4;
    N4 -> N5;
}
```

```dot
digraph main_DFG {
    node [shape=ellipse, style=filled, fillcolor=lightblue];
    const_30 [label="30"];
    node [shape=box, style="", fillcolor=""];
    op_assign_a [label="="];
    op_call_fib [label="fib"];
    op_return [label="return"];
    node [shape=ellipse, style=filled, fillcolor=lightgreen];
    return_val [label="a"];
    const_30 -> op_assign_a;
    op_assign_a -> a;
    a -> op_call_fib;
    a -> op_return;
    op_return -> return_val;
}
```

**Análise de Infeasible Paths:**

NÃO

**Justificativa:**  
O código não contém caminhos inviáveis (infeasible paths). A função `fib` possui um loop com condição `i <= 30 && i <= n`, que é sempre viável para qualquer valor de `n` (inteiro). Se `n < 2`, o loop não é executado, e o valor de retorno é 1 (Fnew inicial). Se `n >= 2`, o loop executa até `i` atingir o mínimo entre 30 e `n`. Não há contradições lógicas ou dependências de dados que impossibilitem qualquer caminho. A função `main` é linear, sem branches, garantindo um único caminho viável.