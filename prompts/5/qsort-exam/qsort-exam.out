**Análise de Caminhos Inviáveis (Infeasible Paths) no Código `qsort-exam.c`**

### 1. Grafo de Fluxo de Controle (CFG) em Graphviz DOT
```dot
digraph CFG {
    node [shape=box, style=rounded, fontname="Helvetica"];
    edge [fontname="Helvetica"];

    // Nós principais
    N1 [label="Main: sort(20);"];
    N2 [label="sort: Inicialização\ni, ir=n, j, k, l=1\njstack=0, flag=0"];
    N3 [label="Loop externo: for (;;)"];
    N4 [label="if (ir - l < M)"];
    N5 [label="Insertion Sort: j = l+1"];
    N6 [label="Loop externo (Insertion): j <= ir"];
    N7 [label="a = arr[j]; i = j-1"];
    N8 [label="Loop interno: i >= l"];
    N9 [label="if (arr[i] <= a)"];
    N10 [label="arr[i+1] = arr[i]; i--"];
    N11 [label="arr[i+1] = a; j++"];
    N12 [label="if (jstack == 0)"];
    N13 [label="break; (fim do loop externo)"];
    N14 [label="Pop da pilha: ir=istack[jstack--]; l=istack[jstack--]"];
    N15 [label="Quicksort: k = (l+ir)>>1; SWAPs; i=l+1; j=ir; a=arr[l+1]"];
    N16 [label="Loop de partição: for (;;)"];
    N17 [label="i++; while (arr[i] < a) i++"];
    N18 [label="j--; while (arr[j] > a) j--"];
    N19 [label="if (j < i)"];
    N20 [label="SWAP(arr[i], arr[j])"];
    N21 [label="arr[l+1]=arr[j]; arr[j]=a; jstack+=2"];
    N22 [label="if (ir-i+1 >= j-l)"];
    N23 [label="Push direita: istack[jstack]=ir; istack[jstack-1]=i; ir=j-1"];
    N24 [label="Push esquerda: istack[jstack]=j-1; istack[jstack-1]=l; l=i"];
    N25 [label="Fim da função sort"];

    // Arestas do CFG
    N1 -> N2;
    N2 -> N3;
    N3 -> N4;
    N4 -> N5 [label="true"];
    N4 -> N15 [label="false"];
    N5 -> N6;
    N6 -> N7 [label="true"];
    N6 -> N12 [label="false"];
    N7 -> N8;
    N8 -> N9 [label="true"];
    N8 -> N11 [label="false"];
    N9 -> N11 [label="true (break)"];
    N9 -> N10 [label="false"];
    N10 -> N8;
    N11 -> N6;
    N12 -> N13 [label="true"];
    N12 -> N14 [label="false"];
    N13 -> N25;
    N14 -> N3;
    N15 -> N16;
    N16 -> N17;
    N17 -> N18;
    N18 -> N19;
    N19 -> N21 [label="true (break)"];
    N19 -> N20 [label="false"];
    N20 -> N16;
    N21 -> N22;
    N22 -> N23 [label="true"];
    N22 -> N24 [label="false"];
    N23 -> N3;
    N24 -> N3;
}
```

### 2. Grafo de Fluxo de Dados (DFG) em Graphviz DOT
```dot
digraph DFG {
    node [shape=box, style="", fillcolor=""];
    edge [fontname="Helvetica"];

    // Variáveis e operações
    arr [label="arr[]", shape=ellipse, fillcolor=lightblue];
    istack [label="istack[]", shape=ellipse, fillcolor=lightblue];
    n [label="n", shape=ellipse, fillcolor=lightblue];
    temp [label="temp", shape=ellipse, fillcolor=lightblue];

    // Operações principais
    op_init [label="Inicialização: i, ir, j, k, l, jstack, flag"];
    op_swap1 [label="SWAP(arr[k], arr[l+1])"];
    op_swap2 [label="SWAP(arr[l], arr[ir])"];
    op_swap3 [label="SWAP(arr[l+1], arr[ir])"];
    op_swap4 [label="SWAP(arr[l], arr[l+1])"];
    op_assign_a [label="a = arr[l+1]"];
    op_compare [label="Comparações: arr[i] < a, arr[j] > a, j < i"];
    op_stack_push [label="Push na pilha: istack[jstack] = ir; istack[jstack-1] = l"];
    op_stack_pop [label="Pop da pilha: ir=istack[jstack--]; l=istack[jstack--]"];

    // Fluxo de dados
    n -> op_init;
    arr -> op_swap1;
    arr -> op_swap2;
    arr -> op_swap3;
    arr -> op_swap4;
    arr -> op_assign_a;
    arr -> op_compare;
    op_assign_a -> op_compare;
    istack -> op_stack_pop;
    op_stack_push -> istack;
    temp -> op_swap1;
    temp -> op_swap2;
    temp -> op_swap3;
    temp -> op_swap4;
}
```

### 3. Análise de Caminhos Inviáveis
**Resposta: NÃO**

#### Justificativa com base no CFG e DFG:
- **Não há contradições lógicas entre condições**: As condições no código (ex: `ir-l < M`, `jstack == 0`, `j < i`) são avaliadas de forma independente e não impõem restrições mutuamente exclusivas ao longo de um mesmo caminho.
- **Dependências de dados são consistentes**: Todas as variáveis são inicializadas antes do uso (ex: `ir` recebe `n`, `jstack` inicia em 0). O DFG mostra que os dados fluem sem conflitos (ex: `arr[]` é modificado via `SWAP` mas sempre em contextos válidos).
- **Loops são viáveis**: As condições de loop (ex: `i >= l`, `j <= ir`) são controladas por variáveis que são devidamente incrementadas/decrementadas, não criando cenários inatingíveis.
- **Não há invariantes de programa restritivos**: O algoritmo de ordenação não possui regras de negócio que bloqueiem caminhos (ex: todos os caminhos lidam com subarrays de tamanho variável de forma coerente).
- **Conclusão**: Todos os caminhos no CFG são executáveis para entradas válidas (ex: `n > 0`), e o DFG confirma que as dependências de dados não criam cenários inviáveis.