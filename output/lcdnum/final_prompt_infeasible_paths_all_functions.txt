[code]
/* MDH WCET BENCHMARK SUITE. */

/* 2012/09/28, Jan Gustafsson <jan.gustafsson@mdh.se>
 * Changes:
 *  - The volatile variable n controls a loop, which is not correct. The loop will not terminate. Fixed.
 */

/***********************************************************************
 *  FILE: synthetic.c
 *
 *  PURPOSE: demonstrate effect of flow facts for straight loops
 *
 *  IDEA: reading from an in port mapped to a ten-item buffer,
 *        send first five characters to an LCD as numbers
 *
 ***********************************************************************/


unsigned char num_to_lcd(unsigned char a)
{
  /*   -0-            1            01
   *  1   2         2   4        02  04
   *   -3-    i.e.    8     i.e.   08
   *  4   5        16   32       10  20
   *   -6-           64            40
   *
   */
  switch(a)
    {
    case 0x00: return 0;
    case 0x01: return 0x24;
    case 0x02: return 1+4+8+16+64;
    case 0x03: return 1+4+8+32+64;
    case 0x04: return 2+4+8+32;
    case 0x05: return 1+4+8+16+64;
    case 0x06: return 1+2+8+16+32+64;
    case 0x07: return 1+4+32;
    case 0x08: return 0x7F;     /* light all */
    case 0x09: return 0x0F + 32 + 64;
    case 0x0A: return 0x0F + 16 + 32;
    case 0x0B: return 2+8+16+32+64;
    case 0x0C: return 1+2+16+64;
    case 0x0D: return 4+8+16+32+64;
    case 0x0E: return 1+2+8+16+64;
    case 0x0F: return 1+2+8+16;
    }
  return 0;
}

volatile unsigned char IN;
volatile unsigned char OUT;

int main(void)
{
  int           i;
  unsigned char a;
  /*volatile*/ int  n; /* JG */

  n = 10;
  for(i=0; i< n; i++)
    {
      a = IN;                   /* scan port */
      if(i<5)
        {
          a = a &0x0F;
          OUT = num_to_lcd(a);
        }
    }
  return 0;
}

---

---
[cdfg num_to_lcd]

```dot
digraph num_to_lcd {
    rankdir=TB;
    
    1 [label="1", xlabel="C-Use: a\nDef: OUT"];
    2 [label="2", xlabel="Case 0x00"];
    3 [label="3", xlabel="Case 0x01"];
    4 [label="4", xlabel="Case 0x02"];
    5 [label="5", xlabel="Case 0x03"];
    6 [label="6", xlabel="Case 0x04"];
    7 [label="7", xlabel="Case 0x05"];
    8 [label="8", xlabel="Case 0x06"];
    9 [label="9", xlabel="Case 0x07"];
    10[label="10", xlabel="Case 0x08"];
    11[label="11", xlabel="Case 0x09"];
    12[label="12", xlabel="Case 0x0A"];
    13[label="13", xlabel="Case 0x0B"];
    14[label="14", xlabel="Case 0x0C"];
    15[label="15", xlabel="Case 0x0D"];
    16[label="16", xlabel="Case 0x0E"];
    17[label="17", xlabel="Case 0x0F"];
    18[label="18", shape=doublecircle];
    
    1 -> 2 [label="a == 0x00"];
    1 -> 3 [label="a == 0x01"];
    1 -> 4 [label="a == 0x02"];
    1 -> 5 [label="a == 0x03"];
    1 -> 6 [label="a == 0x04"];
    1 -> 7 [label="a == 0x05"];
    1 -> 8 [label="a == 0x06"];
    1 -> 9 [label="a == 0x07"];
    1 -> 10[label="a == 0x08"];
    1 -> 11[label="a == 0x09"];
    1 -> 12[label="a == 0x0A"];
    1 -> 13[label="a == 0x0B"];
    1 -> 14[label="a == 0x0C"];
    1 -> 15[label="a == 0x0D"];
    1 -> 16[label="a == 0x0E"];
    1 -> 17[label="a == 0x0F"];
    
    2 -> 18 [label="Return"];
    3 -> 18 [label="Return"];
    4 -> 18 [label="Return"];
    5 -> 18 [label="Return"];
    6 -> 18 [label="Return"];
    7 -> 18 [label="Return"];
    8 -> 18 [label="Return"];
    9 -> 18 [label="Return"];
    10-> 18 [label="Return"];
    11-> 18 [label="Return"];
    12-> 18 [label="Return"];
    13-> 18 [label="Return"];
    14-> 18 [label="Return"];
    15-> 18 [label="Return"];
    16-> 18 [label="Return"];
    17-> 18 [label="Return"];
}
```

<codigos - num_to_lcd>
Node 1:
unsigned char num_to_lcd(unsigned char a)
{
    /*   -0-            1            01
     *  1   2         2   4        02  04
     *   -3-    i.e.    8     i.e.   08
     *  4   5        16   32       10  20
     *   -6-           64            40
     *
     */
    switch(a)
      {
Node 2:
case 0x00: return 0;
Node 3:
case 0x01: return 0x24;
Node 4:
case 0x02: return 1+4+8+16+64;
Node 5:
case 0x03: return 1+4+8+32+64;
Node 6:
case 0x04: return 2+4+8+32;
Node 7:
case 0x05: return 1+4+8+16+64;
Node 8:
case 0x06: return 1+2+8+16+32+64;
Node 9:
case 0x07: return 1+4+32;
Node 10:
case 0x08: return 0x7F;     /* light all */
Node 11:
case 0x09: return 0x0F + 32 + 64;
Node 12:
case 0x0A: return 0x0F + 16 + 32;
Node 13:
case 0x0B: return 2+8+16+32+64;
Node 14:
case 0x0C: return 1+2+16+64;
Node 15:
case 0x0D: return 4+8+16+32+64;
Node 16:
case 0x0E: return 1+2+8+16+64;
Node 17:
case 0x0F: return 1+2+8+16;
}
Node 18:
return 0;
</codigos>
---

---
[analise infeasible_paths num_to_lcd]

```markdown
# Caminhos Inviáveis Identificados

1. **Caminho Inviável [num_to_lcd]**
   - **Trechos de Código**:  
     - Linha [1]: `function num_to_lcd`  
     - Linha [2-17]: Cada caso do switch (0x00 a 0x0F)  
     - Linha [18]: `return 0`  
   - **Descrição**: Sequência de nós como Node 1 → Node X (X: 2-17) → Node 18  
   - **Motivo**: Contradição lógica - Após um caso do switch retornar, o código não pode chegar à instrução `return 0` em Node 18. Cada caminho que inclui Node 18 após um nó de caso é inalcançável.
```
---

---
[cdfg main]

The problem requires constructing a Control Flow Graph (CFG) for a given code snippet. The code initializes `n` to 10 and then enters a loop that runs while `i` is less than `n`. Inside the loop, it reads a value into `a`, checks if `i` is less than 5, and processes `a` accordingly.

### Step-by-Step Explanation:

1. **Node 1: Initialization of n**
   - **Code:** `n = 10;`
   - **Defs:** `{n}`
   - **Uses:** `None`

2. **Node 2: Loop Initialization**
   - **Code:** `for (i = 0; i < n; i++) { ... }`
   - **Defs:** `{i}` (initialized to 0)
   - **Uses:** `None`

3. **Node 3: Loop Condition Check**
   - **Code:** `if (i < n) { ... } else { return; }`
   - **Uses:** `{i, n}`
   - **Outgoing Edges:**
     - If true → Node 4
     - If false → Return (exit function)

4. **Node 4: Read IN into a**
   - **Code:** `a = IN;`
   - **Defs:** `{a}`
   - **Uses:** `{IN}`

5. **Node 5: Check if i < 5**
   - **Code:** `if (i < 5) { ... } else { continue; }`
   - **Uses:** `{i}`
   - **Outgoing Edges:**
     - If true → Node 6
     - If false → Exit loop body and proceed to next iteration

6. **Node 6: Process a**
   - **Code:**
     ```
     a = a & 0x0F;
     OUT = func(a);
     ```
   - **Defs:** `{a, OUT}`
   - **Uses:** `{a}` (and implicitly `OUT` is used)

7. **Flow Control After Node 6:**
   - **Edge from Node 6 to Node 3:**
     - Represents the completion of processing and returning to check the loop condition again after incrementing `i`.

8. **Return Statement:**
   - **Code:** `return;`
   - **Defs:** `{none}`
   - **Uses:** `{none}`

### Summary:
- The graph starts with initializing `n` and then entering a loop.
- Each iteration reads a value into `a`, checks if `i` is less than 5, processes `a` if true, and continues looping until `i` reaches `n`.
- Nodes represent specific code operations, and edges show control flow based on conditions.

This structured approach ensures each part of the code is represented accurately in the Control Flow Graph.
---

---
[analise infeasible_paths main]

```markdown
# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.
```
---

---
**Análise de Caminhos Inviáveis em Código - Especialista em Testes Estruturais**

**Instruções de Entrada:**  
Forneça:  
1. O código-fonte a ser analisado  
2. Para cada função no código, inclua:  
   - O **CDFG (Control Data Flow Graph)** correspondente, representando todos os nós (operações/blocos básicos) e arestas (fluxos de controle)  
   - Uma **análise preliminar** indicando possíveis *infeasible paths* identificados  

---

**Processo de Análise (Executado Automaticamente):**  

**1. Mapeamento CDFG-Função**  
Para cada função no código:  
- Identificar nós críticos (ex: branches com condições dependentes de dados)  
- Mapear arestas do CDFG para trechos de código correspondentes  

**2. Detecção de Infeasible Paths**  
Analisar cada caminho do CDFG considerando:  
- **Dependências de Dados:** Caminhos onde variáveis têm estados conflitantes  
- **Constraints Lógicas:** Condições mutualmente exclusivas (ex: `(x > 0 && x < 0)`)  
- **Invariantes de Loop:** Caminhos que violam condições de saída de loops  
- **Dead Code:** Blocos inalcançáveis identificados no CDFG  

**3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**4. Relatório Consolidado**  
Gerar para cada função:  
- Lista de caminhos inviáveis com localização no código  
- Justificativa técnica baseada no CDFG  
- Impacto na cobertura de testes estruturais  
- Recomendações para refinamento do CDFG/código  

---

**Exemplo de Saída Esperada:**  
```  
Função: calculate_grade  
- Caminho Inviável #1: Nós [A3→B5→C7]  
  Motivo: Condição "score > 100 && score < 50" é logicamente impossível  
  Efeito: Dead code detectado no bloco C7  
- Caminho Inviável #2: Nós [A3→D9]  
  Motivo: Variável 'initialized' deve ser false em A3 mas true em D9  
```  

**Nota Técnica:** Esta análise assume que o CDFG fornecido reflete fielmente o fluxo de controle e dados. Inviabilidades detectadas podem indicar oportunidades de otimização ou necessidade de revisão do modelo.
---
