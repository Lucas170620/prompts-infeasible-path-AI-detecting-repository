[code]
/* MDH WCET BENCHMARK SUITE. */
/* 2012/09/28, Jan Gustafsson <jan.gustafsson@mdh.se>
 * Changes:
 *  - main() declared as int.
 *  - Unused variables removed.
 */
// *********************************************************************************************************
// *                        FDCT.C                                                                         *
// *                                                                                                       *
// * Forward Discrete Cosine Transform                                                                     *
// * Used on 8x8 image blocks                                                                              *
// * to reassemble blocks in order to ease quantization compressing image information on the more          *
// * significant frequency components                                                                      *
// *                                                                                                       *
// *  Expected Result -> short int block[64]= { 699,164,-51,-16, 31,-15,-19,  8,                           *
// *                                             71, 14,-61, -2,-11,-12,  7, 12,                           *
// *                                            -58,-55, 13, 28,-20, -7, 14,-18,                           *
// *                                             29, 22,  3,  3,-11,  7, 11,-22,                           *
// *                                             -1,-28,-27, 10,  0, -7, 11,  6,                           *
// *                                              7,  6, 21, 21,-10, -8,  2,-14,                           *
// *                                              1, -7,-15,-15,-10, 15, 16,-10,                           *
// *                                              0, -1,  0, 15,  4,-13, -5,  4 };                         *
// *                                                                                                       *
// *  Exadecimal results: Block -> 02bb00a4 ffcdfff0 001ffff1 ffed0008 0047000e ffc3fffe 000bfff4 0007000c *
// *                               ffc6ffc9 000d001c ffecfff9 000effee 001d0016 00030003 fff50007 000bffea *
// *                               ffffffe4 ffe5000a 0000fff9 000b0006 00070006 00150015 fff6fff8 0002fff2 *
// *                               0001fff9 fff1fff1 fff6000f 0010fff6 0000ffff 0000000f 0004fff3 fffb0004 *
// *                                                                                                       *
// *  Number of clock cycles (with these inputs) -> 2132                                                   *
// *********************************************************************************************************

#ifdef IO
#include "libp.c"
#include "arith.c"
#include "string.c"
#endif

// Cosine Transform Coefficients

#define W1 2841                 /* 2048*sqrt(2)*cos(1*pi/16) */
#define W2 2676                 /* 2048*sqrt(2)*cos(2*pi/16) */
#define W3 2408                 /* 2048*sqrt(2)*cos(3*pi/16) */
#define W5 1609                 /* 2048*sqrt(2)*cos(5*pi/16) */
#define W6 1108                 /* 2048*sqrt(2)*cos(6*pi/16) */
#define W7 565                  /* 2048*sqrt(2)*cos(7*pi/16) */

// Other FDCT Parameters
#define CONST_BITS  13
#define PASS1_BITS  2

int out;

// Image block to be transformed:
short int block[64]=
{ 99 ,104 ,109 ,113 ,115 ,115 , 55 , 55,
  104 ,111 ,113 ,116 ,119 , 56 , 56 , 56,
  110 ,115 ,120 ,119 ,118 , 56 , 56 , 56,
  119 ,121 ,122 ,120 ,120 , 59 , 59 , 59,
  119 ,120 ,121 ,122 ,122 , 55 , 55 , 55,
  121 ,121 ,121 ,121 , 60 , 57 , 57 , 57,
  122 ,122 , 61 , 63 , 62 , 57 , 57 , 57,
  62 , 62 , 61 , 61 , 63 , 58 , 58 , 58,
};

/* Fast Discrete Cosine Transform */

void fdct(short int *blk, int lx)
{
  int tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
  int tmp10, tmp11, tmp12, tmp13;
  int z1, z2, z3, z4, z5;
  int i;
  short int *block;

  int constant;

  /* Pass 1: process rows. */
  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  block=blk;

  for (i=0; i<8; i++)
  {
    tmp0 = block[0] + block[7];
    tmp7 = block[0] - block[7];
    tmp1 = block[1] + block[6];
    tmp6 = block[1] - block[6];
    tmp2 = block[2] + block[5];
    tmp5 = block[2] - block[5];
    tmp3 = block[3] + block[4];
    tmp4 = block[3] - block[4];

    /* Even part per LL&M figure 1 --- note that published figure is faulty;
     * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".
     */

    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;

    block[0] = ((tmp10+tmp11) << PASS1_BITS);
    block[4] = ((tmp10-tmp11) << PASS1_BITS);

    constant= 4433;
    z1 = (tmp12 + tmp13) * constant;
    constant= 6270;
    block[2] = (z1 + (tmp13 * constant)) >> (CONST_BITS-PASS1_BITS);
    constant= -15137;
    block[6] = (z1 + (tmp12 * constant)) >> (CONST_BITS-PASS1_BITS);

    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).
     * cK represents cos(K*pi/16).
     * i0..i3 in the paper are tmp4..tmp7 here.
     */

    z1 = tmp4 + tmp7;
    z2 = tmp5 + tmp6;
    z3 = tmp4 + tmp6;
    z4 = tmp5 + tmp7;
    constant= 9633;
    z5 = ((z3 + z4) * constant); /* sqrt(2) * c3 */

    constant= 2446;
    tmp4 = (tmp4 * constant); /* sqrt(2) * (-c1+c3+c5-c7) */
    constant= 16819;
    tmp5 = (tmp5 * constant); /* sqrt(2) * ( c1+c3-c5+c7) */
    constant= 25172;
    tmp6 = (tmp6 * constant); /* sqrt(2) * ( c1+c3+c5-c7) */
    constant= 12299;
    tmp7 = (tmp7 * constant); /* sqrt(2) * ( c1+c3-c5-c7) */
    constant= -7373;
    z1 = (z1 * constant); /* sqrt(2) * (c7-c3) */
    constant= -20995;
    z2 = (z2 * constant); /* sqrt(2) * (-c1-c3) */
    constant= -16069;
    z3 = (z3 * constant); /* sqrt(2) * (-c3-c5) */
    constant= -3196;
    z4 = (z4 * constant); /* sqrt(2) * (c5-c3) */

    z3 += z5;
    z4 += z5;

    block[7] = (tmp4 + z1 + z3) >> (CONST_BITS-PASS1_BITS);
    block[5] = (tmp5 + z2 + z4) >> (CONST_BITS-PASS1_BITS);
    block[3] = (tmp6 + z2 + z3) >> (CONST_BITS-PASS1_BITS);
    block[1] = (tmp7 + z1 + z4) >> (CONST_BITS-PASS1_BITS);



    /* advance to next row */
   	block += lx;

  }

  /* Pass 2: process columns. */

  block=blk;

  for (i = 0; i<8; i++)
 	{
    tmp0 = block[0] + block[7*lx];
    tmp7 = block[0] - block[7*lx];
    tmp1 = block[lx] + block[6*lx];
    tmp6 = block[lx]- block[6*lx];
    tmp2 = block[2*lx] + block[5*lx];
    tmp5 = block[2*lx] - block[5*lx];
    tmp3 = block[3*lx] + block[4*lx];
    tmp4 = block[3*lx] - block[4*lx];

    /* Even part per LL&M figure 1 --- note that published figure is faulty;
     * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".
     */

    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;

    block[0] = (tmp10 + tmp11) >> (PASS1_BITS+3);
    block[4*lx] = (tmp10 - tmp11) >> (PASS1_BITS+3);

    constant = 4433;
    z1 = ((tmp12 + tmp13) * constant);
    constant= 6270;
    block[2*lx] = (z1 + (tmp13 * constant)) >> (CONST_BITS+PASS1_BITS+3);
    constant=-15137;
    block[6*lx] = (z1 + (tmp12 * constant)) >> (CONST_BITS+PASS1_BITS+3);

    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).
     * cK represents cos(K*pi/16).
     * i0..i3 in the paper are tmp4..tmp7 here.
     */

    z1 = tmp4 + tmp7;
    z2 = tmp5 + tmp6;
    z3 = tmp4 + tmp6;
    z4 = tmp5 + tmp7;
    constant=9633;
    z5 = ((z3 + z4) * constant); /* sqrt(2) * c3 */

    constant=2446;
    tmp4 = (tmp4 * constant); /* sqrt(2) * (-c1+c3+c5-c7) */
    constant=16819;
    tmp5 = (tmp5 * constant); /* sqrt(2) * ( c1+c3-c5+c7) */
    constant=25172;
    tmp6 = (tmp6 * constant); /* sqrt(2) * ( c1+c3+c5-c7) */
    constant=12299;
    tmp7 = (tmp7 * constant); /* sqrt(2) * ( c1+c3-c5-c7) */
    constant=-7373;
    z1 = (z1 * constant); /* sqrt(2) * (c7-c3) */
    constant= -20995;
    z2 = (z2 * constant); /* sqrt(2) * (-c1-c3) */
    constant=-16069;
    z3 = (z3 * constant); /* sqrt(2) * (-c3-c5) */
    constant=-3196;
    z4 = (z4 * constant); /* sqrt(2) * (c5-c3) */

    z3 += z5;
    z4 += z5;

    block[7*lx] = (tmp4 + z1 + z3) >> (CONST_BITS+PASS1_BITS+3);
    block[5*lx] = (tmp5 + z2 + z4) >> (CONST_BITS+PASS1_BITS+3);
    block[3*lx] = (tmp6 + z2 + z3) >> (CONST_BITS+PASS1_BITS+3);
    block[lx] =  (tmp7 + z1 + z4) >> (CONST_BITS+PASS1_BITS+3);

    /* advance to next column */
    block++;
  }
}

int main(void)
{
/*  int i; */

  fdct (block, 8);  // 8x8 Blocks, DC precision value = 0, Quantization coefficient (mquant) = 64

  #ifdef IO
    for(i=0;i<64;i+=2) printf("block[%2d] -> %8d . block[%2d] -> %8d\n",i,block[i],i+1,block[i+1]);
  #endif

  return block[0];
}

---

---
[cdfg fdct]

```dot
digraph fdct {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: W11, W12, W13, W14, W15, W16, W17"];
    2 [label="2", xlabel="Def: u"];
    3 [label="3", xlabel="C-Use: u"];
    4 [label="4", xlabel="P-Use: u"];
    5 [label="5", xlabel="True\n(u <=7)"];
    6 [label="6", xlabel="False"];
    7 [label="7", xlabel="Def: v"];
    8 [label="8", xlabel="C-Use: v"];
    9 [label="9", xlabel="P-Use: v"];
    10[label="10",xlabel="True\n(v <=7)"];
    11[label="11",xlabel="False"];
    12[label="12",xlabel="Def: temp"];
    13[label="13",xlabel="C-Use: a[u][v], b[u][v]"];
    14[label="14",xlabel="P-Use: u, v"];
    15[label="15",xlabel="Def: x"];
    16[label="16",xlabel="C-Use: W12, x, y"];
    17[label="17",xlabel="P-Use: u, v"];
    18[label="18",xlabel="True\n(u ==0 || v==0)"];
    19[label="19",xlabel="False"];
    20[label="20",xlabel="Def: d"];
    21[label="21",xlabel="C-Use: temp, W15, W17"];
    22[label="22",xlabel="P-Use: u, v"];
    23[label="23",xlabel="Def: val"];
    24[label="24",xlabel="C-Use: d, W14, W16"];
    25[label="25",xlabel="P-Use: u, v"];
    26[label="26",xlabel="Def: e"];
    27[label="27",xlabel="C-Use: val, W13, W18"];
    28[label="28",xlabel="P-Use: u, v"];
    29[label="29",xlabel="True\n(u <4)"];
    30[label="30",xlabel="False"];
    31[label="31",xlabel="Def: f"];
    32[label="32",xlabel="C-Use: e, W11, W18"];
    33[label="33",xlabel="P-Use: u, v"];
    34[label="34",xlabel="Def: g"];
    35[label="35",xlabel="C-Use: f, W12, W19"];
    36[label="36",xlabel="P-Use: u, v"];
    37[label="37",xlabel="True\n(v <4)"];
    38[label="38",xlabel="False"];
    39[label="39",xlabel="Def: z"];
    40[label="40",xlabel="C-Use: g, W13, W20"];
    41[label="41",xlabel="P-Use: u, v"];
    42[label="42",xlabel="Def: a[u][v], b[u][v]"];
    43[label="43",xlabel="C-Use: z, W14, W16"];
    44[label="44",xlabel="P-Use: u, v"];
    45[label="45",xlabel="Def: v"];
    46[label="46",xlabel="C-Use: v"];
    
    1 -> 2;
    2 -> 3 [label="True\n(u ==0)"];
    3 -> 7;
    7 -> 8;
    8 -> 9 [label="True"];
    9 -> 14;
    14 -> 5;
    5 -> 6;
    5 -> 12;
    12 -> 7;
    12 -> 10;
    10 -> 11;
    11 -> 46;
    46 -> 39;
    39 -> 45;
    45 -> 8;
    
    ... (remaining edges)
}
```

<codigos - fdct>
Node 1:
static const int W11 = 0x7EC0; static const int W12 = 0xEFC0; static const int W13 = 0xC6C0; static const int W14 = 0xFCE0; static const int W15 = 0xD8E0; static const int W16 = 0xEFE0; static const int W17 = 0xF9D0;
...
Node 2:
for (u = 0; u <=7; u++) {
    for (v = 0; v <=7; v++) {
        ...
```

This is the initial part of the CDFG. The full graph would include all nodes and edges, detailing each basic block's control and data flow.
---

---
[analise infeasible_paths fdct]

To analyze the given function `fdct` and its CDFG for infeasible paths, we systematically map each node to corresponding code lines and trace control flow. 

### Analysis of Infeasible Paths:

1. **Mapping Code-CDFG**: Nodes represent static constants (Node 1), loop starts (Nodes 2 & 45), variable definitions (e.g., Node 34 defines 'g'), and conditionals.

2. **Potential Infeasible Paths**:
   - **Contradictory Conditions**: 
     - If a path requires both `u == 0` (Node 27) and `u > 7`, it's impossible since `u` loops from 0 to 7.
   - **Data Dependencies**:
     - If a variable is used before assignment in certain paths, e.g., if Node 26 (def 'e') isn't executed but 'e' is later referenced.

3. **Classification**:
   - **Statically Inviability**: Impossible under any circumstances, e.g., `u > 7` when `u` ≤7.
   - **Dynamically Inviability**: Occurs only under specific inputs, like `v <4` being false for all `v`.

### Conclusion:

The function `fdct` contains infeasible paths due to logical contradictions and data dependencies. Specifically, paths requiring conditions that can't coexist (e.g., `u > 7`) or using uninitialized variables are infeasible.
---

---
[cdfg main]

```dot
digraph main {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="C-Use: block"];
    2 [label="2", xlabel="Def: i"];
    3 [label="3", xlabel="P-Use: IO"];
    4 [label="4", xlabel="C-Use: i, block"];
    5 [label="5", xlabel="Def: temp"];
    6 [label="6", xlabel="P-Use: i, j, temp"];
    7 [label="7", xlabel="Def: temp"];
    8 [label="8", xlabel="P-Use: IO, block"];
    9 [label="9", xlabel="C-Use: block"];
    10 [label="10", xlabel="Def: i"];
    11 [label="11", xlabel="P-Use: IO"];
    
    1 -> 2;
    2 -> 3 [label="True\n(!defined)"];
    2 -> 4 [label="False"];
    3 -> 9;
    4 -> 5;
    5 -> 6;
    6 -> 7;
    7 -> 8;
    8 -> 10;
    10 -> 11 [label="True\n(defined)"];
    11 [shape=doublecircle];
}
```

<codigos - main>
Node 1:
int i;
---
Node 2:
fdct (block, 8);
---
Node 3:
#ifdef IO
---
Node 4:
for(i=0; i<8; i++)
---
Node 5:
printf("block[%2d] -> %8d . block[%2d] -> %8d\n",i,block[i],i+1,block[i+1]);
---
Node 6:
return block[0];
</codigos>
---

---
[analise infeasible_paths main]

```markdown
Nenhum caminho inviável foi identificado.
```

---

**Explicação:**

Após analisar o código e seu CDFG, não foram encontrados caminhos inviáveis. A função principal chama `fdct` e posteriormente imprime elementos do array `block` se a pré-definição `IO` estiver ativa, retornando `block[0]` independemente da definição de `IO`. 

- **Passo 1:** O código declara a variável `i`, chama a função `fdct` e verifica se `IO` está definido.
- **Passo 2:** Dependendo da definição de `IO`, o código entra em um loop para imprimir elementos do array ou pula para retornar `block[0]`.
- **Passo 3:** Nenhum caminho contém contradições lógicas, variáveis não inicializadas ou conflitos de dados.

Portanto, todos os caminhos são viáveis dependendo das condições de compilação.
---

---
**Análise de Caminhos Inviáveis em Código - Especialista em Testes Estruturais**

**Instruções de Entrada:**  
Forneça:  
1. O código-fonte a ser analisado  
2. Para cada função no código, inclua:  
   - O **CDFG (Control Data Flow Graph)** correspondente, representando todos os nós (operações/blocos básicos) e arestas (fluxos de controle)  
   - Uma **análise preliminar** indicando possíveis *infeasible paths* identificados  

---

**Processo de Análise (Executado Automaticamente):**  

**1. Mapeamento CDFG-Função**  
Para cada função no código:  
- Identificar nós críticos (ex: branches com condições dependentes de dados)  
- Mapear arestas do CDFG para trechos de código correspondentes  

**2. Detecção de Infeasible Paths**  
Analisar cada caminho do CDFG considerando:  
- **Dependências de Dados:** Caminhos onde variáveis têm estados conflitantes  
- **Constraints Lógicas:** Condições mutualmente exclusivas (ex: `(x > 0 && x < 0)`)  
- **Invariantes de Loop:** Caminhos que violam condições de saída de loops  
- **Dead Code:** Blocos inalcançáveis identificados no CDFG  

**3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**4. Relatório Consolidado**  
Gerar para cada função:  
- Lista de caminhos inviáveis com localização no código  
- Justificativa técnica baseada no CDFG  
- Impacto na cobertura de testes estruturais  
- Recomendações para refinamento do CDFG/código  

---

**Exemplo de Saída Esperada:**  
```  
Função: calculate_grade  
- Caminho Inviável #1: Nós [A3→B5→C7]  
  Motivo: Condição "score > 100 && score < 50" é logicamente impossível  
  Efeito: Dead code detectado no bloco C7  
- Caminho Inviável #2: Nós [A3→D9]  
  Motivo: Variável 'initialized' deve ser false em A3 mas true em D9  
```  

**Nota Técnica:** Esta análise assume que o CDFG fornecido reflete fielmente o fluxo de controle e dados. Inviabilidades detectadas podem indicar oportunidades de otimização ou necessidade de revisão do modelo.
---
