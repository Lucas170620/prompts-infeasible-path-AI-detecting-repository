[code]
/* $Id: crc.c,v 1.2 2005/04/04 11:34:58 csg Exp $ */

/*************************************************************************/
/*                                                                       */
/*   SNU-RT Benchmark Suite for Worst Case Timing Analysis               */
/*   =====================================================               */
/*                              Collected and Modified by S.-S. Lim      */
/*                                           sslim@archi.snu.ac.kr       */
/*                                         Real-Time Research Group      */
/*                                        Seoul National University      */
/*                                                                       */
/*                                                                       */
/*        < Features > - restrictions for our experimental environment   */
/*                                                                       */
/*          1. Completely structured.                                    */
/*               - There are no unconditional jumps.                     */
/*               - There are no exit from loop bodies.                   */
/*                 (There are no 'break' or 'return' in loop bodies)     */
/*          2. No 'switch' statements.                                   */
/*          3. No 'do..while' statements.                                */
/*          4. Expressions are restricted.                               */
/*               - There are no multiple expressions joined by 'or',     */
/*                'and' operations.                                      */
/*          5. No library calls.                                         */
/*               - All the functions needed are implemented in the       */
/*                 source file.                                          */
/*                                                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*  FILE: crc.c                                                          */
/*  SOURCE : Numerical Recipes in C - The Second Edition                 */
/*                                                                       */
/*  DESCRIPTION :                                                        */
/*                                                                       */
/*     A demonstration for CRC (Cyclic Redundancy Check) operation.      */
/*     The CRC is manipulated as two functions, icrc1 and icrc.          */
/*     icrc1 is for one character and icrc uses icrc1 for a string.      */
/*     The input string is stored in array lin[].                        */
/*     icrc is called two times, one for X-Modem string CRC and the      */
/*     other for X-Modem packet CRC.                                     */
/*                                                                       */
/*  REMARK :                                                             */
/*                                                                       */
/*  EXECUTION TIME :                                                     */
/*                                                                       */
/*                                                                       */
/*************************************************************************/


typedef unsigned char uchar;
#define LOBYTE(x) ((uchar)((x) & 0xFF))
#define HIBYTE(x) ((uchar)((x) >> 8))

unsigned char lin[256] = "asdffeagewaHAFEFaeDsFEawFdsFaefaeerdjgp";

unsigned short icrc1(unsigned short crc, unsigned char onech)
{
	int i;
	unsigned short ans=(crc^onech << 8);

	for (i=0;i<8;i++) {
		if (ans & 0x8000)
			ans = (ans <<= 1) ^ 4129;
		else
			ans <<= 1;
	}
	return ans;
}

unsigned short icrc(unsigned short crc, unsigned long len,
		    short jinit, int jrev)
{
  unsigned short icrc1(unsigned short crc, unsigned char onech);
  static unsigned short icrctb[256],init=0;
  static uchar rchr[256];
  unsigned short tmp1, tmp2, j,cword=crc;
  static uchar it[16]={0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};

  if (!init) {
    init=1;
    for (j=0;j<=255;j++) {
      icrctb[j]=icrc1(j << 8,(uchar)0);
      rchr[j]=(uchar)(it[j & 0xF] << 4 | it[j >> 4]);
    }
  }
  if (jinit >= 0) cword=((uchar) jinit) | (((uchar) jinit) << 8);
  else if (jrev < 0)
    cword=rchr[HIBYTE(cword)] | rchr[LOBYTE(cword)] << 8;
#ifdef DEBUG
  printf("len = %d\n", len);
#endif
  for (j=1;j<=len;j++) {
    if (jrev < 0) {
      tmp1 = rchr[lin[j]]^ HIBYTE(cword);
    }
    else {
      tmp1 = lin[j]^ HIBYTE(cword);
    }
    cword = icrctb[tmp1] ^ LOBYTE(cword) << 8;
  }
  if (jrev >= 0) {
    tmp2 = cword;
  }
  else {
    tmp2 = rchr[HIBYTE(cword)] | rchr[LOBYTE(cword)] << 8;
  }
  return (tmp2 );
}


int main(void)
{

  unsigned short i1,i2;
  unsigned long n;

  n=40;
  lin[n+1]=0;
  i1=icrc(0,n,(short)0,1);
  lin[n+1]=HIBYTE(i1);
  lin[n+2]=LOBYTE(i1);
  i2=icrc(i1,n+2,(short)0,1);
  return 0;
}

---
[cdfg]

**Parte 1 - Código Graphviz:**

```dot
digraph icrc {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: icrctb, init, rchr\nC-Use: j, it"];
    2 [label="2", xlabel="P-Use: !init"];
    3 [label="3", xlabel="Def: icrctb[j], rchr[j]"];
    4 [label="4", xlabel="P-Use: jinit >=0"];
    5 [label="5", xlabel="Def: cword"];
    6 [label="6", xlabel="P-Use: jrev <0"];
    7 [label="7", xlabel="Def: cword"];
    8 [label="8", xlabel="P-Use: len, jrev"];
    9 [label="9", xlabel="P-Use: lin[j], HIBYTE(cword)"];
    10 [label="10", xlabel="Def: tmp1"];
    11 [label="11", xlabel="Def: cword"];
    12 [label="12", xlabel="P-Use: jrev >=0, HIBYTE(cword), rchr[HIBYTE(cword)], rchr[LOBYTE(cword)]"];
    13 [label="13", xlabel="Def: tmp2"];
    14 [label="14", shape=doublecircle, xlabel="Return: tmp2"];

    1 -> 2;
    2 -> 3 [label="True\n(!init)"];
    2 -> 5 [label="False"];
    3 -> 4;
    4 -> 5 [label="True\n(jinit >=0)"];
    4 -> 6 [label="False"];
    5 -> 7;
    6 -> 7 [label="True\n(jrev <0)"];
    7 -> 8;
    8 -> 9 [label="j <= len"];
    9 -> 10;
    10 -> 11;
    11 -> 8 [label="(loop continue)"];
    11 -> 12 [label="j > len"];
    12 -> 13;
    13 -> 14;
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**

<codigos - icrc>
Node 1:
static unsigned short icrctb[256],init=0;
static uchar rchr[256];
unsigned short tmp1, tmp2, j,cword=crc;
static uchar it[16]={0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};
if (!init) {
    init=1;
    for (j=0;j<=255;j++) {
        icrctb[j]=icrc1(j << 8,(uchar)0);
        rchr[j]=(uchar)(it[j & 0xF] << 4 | it[j >> 4]);
    }
}
---
Node 2:
if (!init)
---
Node 3:
{
    init=1;
    for (j=0;j<=255;j++) {
        icrctb[j]=icrc1(j << 8,(uchar)0);
        rchr[j]=(uchar)(it[j & 0xF] << 4 | it[j >> 4]);
    }
}
---
Node 4:
if (jinit >=0)
cword=((uchar) jinit) | (((uchar) jinit) << 8)
else if (jrev < 0)
cword=rchr[HIBYTE(cword)] | rchr[LOBYTE(cword)] << 8;
if (jrev <0)
    tmp1 = rchr[lin[j]]^ HIBYTE(cword);
else
    tmp1 = lin[j]^ HIBYTE(cword);
cword = icrctb[tmp1] ^ LOBYTE(cword) << 8;
if (jrev >=0) {
    tmp2 = cword;
}
else {
    tmp2 = rchr[HIBYTE(cword)] | rchr[LOBYTE(cword)] << 8;
}
return (tmp2 );
</codigos>
---
 Você é um especialista em engenharia de software com expertise em teste estrutural, CDFG e Graphviz. Sua tarefa é analisar um código e seu CDFG para identificar caminhos inviáveis (*infeasible paths*). Siga **rigorosamente** os passos abaixo.

---

#### **1. Contexto Teórico (Resumo)**  
- **CDFG**: Combina CFG (fluxo de controle) e DFG (fluxo de dados).  
- **Caminhos Inviáveis**: Sequências de nós/arestas inexequíveis devido a:  
  - Contradições lógicas (ex: `x > 10` e `x < 5` no mesmo caminho).  
  - Dependências de dados (ex: variável não inicializada).  
  - Conflitos em condições sequenciais ou invariantes de programa.  

---

#### **2. Exemplo de Análise**  
**Função de Exemplo:**  
```python
def example(x):
    if x > 10:     # Nó A
        y = 5      # Nó B
    else:
        y = 0      # Nó C
    if y < 0:      # Nó D
        return -1  # Nó E
    return y       # Nó F
```

**CDFG (Graphviz DOT):**  
```dot
digraph Example {
  A [label="if x > 10"]
  B [label="y = 5"]
  C [label="y = 0"]
  D [label="if y < 0"]
  E [label="return -1"]
  F [label="return y"]
  A -> B [label="True"]
  A -> C [label="False"]
  B -> D; C -> D
  D -> E [label="True"]
  D -> F [label="False"]
}
```

**Análise:**  
1. **Passo 1:** Rastrear caminhos no CDFG (ex: A→B→D→E).  
2. **Passo 2:** Verificar contradições:  
   - Caminho `A→B→D→E`:  
     - Em `B`, `y = 5`.  
     - Em `D`, a condição `y < 0` é **falsa** porque `y = 5`.  
     - Conclusão: O caminho para `E` é inviável.  
3. **Saída Formatada:**  
   ```markdown
   1. **Caminho Inviável [example]**  
      - **Trechos de Código**:  
        - Linha 2: `if x > 10`  
        - Linha 3: `y = 5`  
        - Linha 6: `if y < 0`  
        - Linha 7: `return -1`  
      - **Descrição**: Nó A → Nó B → Nó D → Nó E  
      - **Motivo**: Contradição lógica: `y = 5` torna a condição `y < 0` falsa.  
   ```

---

#### **3. Tarefa Principal**  
Analise o código e CDFG fornecidos abaixo:

**Função:**  
```<icrc>```

**CDFG (Graphviz DOT):**  
```<INSIRA AQUI O CDFG>```

---

Execute **sequencialmente** estes passos:

**Passo 1: Mapeamento Código-CDFG**  
- Relacione cada nó/aresta do CDFG com trechos do código.  
- Exemplo: "Nó A corresponde à linha 5: `if x > 0`".

**Passo 2: Identificação de Caminhos Potenciais**  
- Liste todos os caminhos possíveis no CDFG (ex: A→B→D, A→C→D).  
- Use a estrutura do CDFG para evitar omissões.

**Passo 3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**Passo 4: Análise de Viabilidade por Critério**  
Para cada caminho:  
1. **Dados**: Variáveis estão inicializadas? Valores são consistentes?  
2. **Lógica**: Condições subsequentes se contradizem?  
3. **Contexto**: Há invariantes (ex: `x ≥ 0`) que bloqueiam o caminho?  
4. **Loop**: Condições de entrada/saída de loops são satisfeitas?

**Passo 5: Consolidação**  
- Filtre caminhos que violam **pelo menos um critério** como inviáveis.  
- Descreva cada um com:  
  - Trechos de código relevantes.  
  - Sequência de nós.  
  - Motivo detalhado (ex: "`x = 5` no nó B contradiz `x != 5` no nó D").

---

#### **5. Formato de Saída Exigido**  
- Se houver caminhos inviáveis:  
  ```markdown
  # Caminhos Inviáveis Identificados

  [Número]. **Caminho Inviável [Nome da Função]**  
    - **Trechos de Código**:  
      - Linha [X]: `[código]`  
      - Linha [Y]: `[código]`  
    - **Descrição**: [Sequência de nós, ex: A → B → C]  
    - **Motivo**: [Explicação técnica com base nos critérios]  
  ```  
- Caso contrário:  
  `"Nenhum caminho inviável foi identificado."`