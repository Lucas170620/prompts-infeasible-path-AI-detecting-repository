[code]
/*----------------------------------------------------------------------
 *  WCET Benchmark created by Andreas Ermedahl, Uppsala university,
 *  May 2000.
 *
 *  The purpose of this benchmark is to have two loop where the inner
 *  loops max number of iterations depends on the outer loops current
 *  iterations.  The results corresponds to something Jannes flow-analysis
 *  should produce.
 *
 * The example appeard for the first time in:
 *
 *  @InProceedings{Ermedahl:Annotations,
 * author =       "A. Ermedahl and J. Gustafsson",
 * title =        "Deriving Annotations for Tight Calculation of Execution Time",
 * year =         1997,
 * month =        aug,
 * booktitle =    EUROPAR97,
 * publisher =    "Springer Verlag",
 * pages =        "1298-1307"
 * }
 *
 * The result of Jannes tool is something like:
 *   outer loop:       1   2   3   4   5   6   7   8   9   10   11
 *   inner loop max:   5   9   8   7   4   2   1   1   1   1    1
 *
 *----------------------------------------------------------------------*/

int complex(int a, int b)
{
  while(a < 30)
    {
      while(b < a)
	{
	  if(b > 5)
	    b = b * 3;
	  else
	    b = b + 2;
	  if(b >= 10 && b <= 12)
	    a = a + 10;
	  else
	    a = a + 1;
	}
      a = a + 2;
      b = b - 10;
    }
  return 1;
}

int main()
{
  /* a = [1..30] b = [1..30] */
  int a = 1, b = 1, answer = 0;
  /* if(answer)
     {a = 1; b = 1;}
     else
     {a = 30; b = 30;} */
  answer = complex(a, b);
  return answer;
}

---

---
[cdfg complex]

---

---
[analise infeasible_paths complex]

---

---
[cdfg main]

```dot
digraph main {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: a, b, answer\nC-Use: complex"];
    2 [label="2", xlabel="P-Use: a"];
    3 [label="3", xlabel="Def: answer\nC-Use: complex"];
    4 [label="4", shape=doublecircle];
    
    1 -> 2 [label="Always true"];
    2 -> 3;
    3 -> 4;
}
```

<codigos - main>
Node 1:
int a = 1, b = 1, answer = 0;
answer = complex(a, b);
return answer;
---
Node 2:
// This node represents the function call
answer = complex(a, b);
---
Node 3:
return answer;
</codigos>
---

---
[analise infeasible_paths main]

```markdown
Nenhum caminho inviável foi identificado.
```

# Caminhos Inviáveis Identificados

1. **Caminho Inválido [main]**
   - **Trechos de Código**:  
     - Linha 1: `int a = 1, b = 1, answer = 0;`
     - Linha 2: `answer = complex(a, b);`
     - Linha 3: `return answer;`
   - **Descrição**: Nó 1 → Nó 2 → Nó 3 → Nó 4
   - **Motivo**: O caminho é totalmente viável como o código não contém condições que possam levar a situações inválidas ou conflitos de dados. As variáveis `a` e `b` são inicializadas adequadamente, e a chamada para `complex()` é sempre realizada.

```markdown
Nenhum caminho inviável foi identificado.
```
---

---
**Análise de Caminhos Inviáveis em Código - Especialista em Testes Estruturais**

**Instruções de Entrada:**  
Forneça:  
1. O código-fonte a ser analisado  
2. Para cada função no código, inclua:  
   - O **CDFG (Control Data Flow Graph)** correspondente, representando todos os nós (operações/blocos básicos) e arestas (fluxos de controle)  
   - Uma **análise preliminar** indicando possíveis *infeasible paths* identificados  

---

**Processo de Análise (Executado Automaticamente):**  

**1. Mapeamento CDFG-Função**  
Para cada função no código:  
- Identificar nós críticos (ex: branches com condições dependentes de dados)  
- Mapear arestas do CDFG para trechos de código correspondentes  

**2. Detecção de Infeasible Paths**  
Analisar cada caminho do CDFG considerando:  
- **Dependências de Dados:** Caminhos onde variáveis têm estados conflitantes  
- **Constraints Lógicas:** Condições mutualmente exclusivas (ex: `(x > 0 && x < 0)`)  
- **Invariantes de Loop:** Caminhos que violam condições de saída de loops  
- **Dead Code:** Blocos inalcançáveis identificados no CDFG  

**3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**4. Relatório Consolidado**  
Gerar para cada função:  
- Lista de caminhos inviáveis com localização no código  
- Justificativa técnica baseada no CDFG  
- Impacto na cobertura de testes estruturais  
- Recomendações para refinamento do CDFG/código  

---

**Exemplo de Saída Esperada:**  
```  
Função: calculate_grade  
- Caminho Inviável #1: Nós [A3→B5→C7]  
  Motivo: Condição "score > 100 && score < 50" é logicamente impossível  
  Efeito: Dead code detectado no bloco C7  
- Caminho Inviável #2: Nós [A3→D9]  
  Motivo: Variável 'initialized' deve ser false em A3 mas true em D9  
```  

**Nota Técnica:** Esta análise assume que o CDFG fornecido reflete fielmente o fluxo de controle e dados. Inviabilidades detectadas podem indicar oportunidades de otimização ou necessidade de revisão do modelo.
---
