[code]
/* $Id: matmult.c,v 1.2 2005/04/04 11:34:58 csg Exp $ */

/* matmult.c */
/* was mm.c! */


/*----------------------------------------------------------------------*
 * To make this program compile under our assumed embedded environment,
 * we had to make several changes:
 * - Declare all functions in ANSI style, not K&R.
 *   this includes adding return types in all cases!
 * - Declare function prototypes
 * - Disable all output
 * - Disable all UNIX-style includes
 *
 * This is a program that was developed from mm.c to matmult.c by
 * Thomas Lundqvist at Chalmers.
 *----------------------------------------------------------------------*/
#define UPPSALAWCET 1


/* ***UPPSALA WCET***:
   disable stupid UNIX includes */
#ifndef UPPSALAWCET
#include <sys/types.h>
#include <sys/times.h>
#endif

/*
 * MATRIX MULTIPLICATION BENCHMARK PROGRAM:
 * This program multiplies 2 square matrices resulting in a 3rd
 * matrix. It tests a compiler's speed in handling multidimensional
 * arrays and simple arithmetic.
 */

#define UPPERLIMIT 20

typedef int matrix [UPPERLIMIT][UPPERLIMIT];

int Seed;
matrix ArrayA, ArrayB, ResultArray;

#ifdef UPPSALAWCET
/* Our picky compiler wants prototypes! */
void Multiply(matrix A, matrix B, matrix Res);
void InitSeed(void);
void Test(matrix A, matrix B, matrix Res);
void Initialize(matrix Array);
int RandomInteger(void);
#endif

void main()
{
   InitSeed();
/* ***UPPSALA WCET***:
   no printing please! */
#ifndef UPPSALAWCET
   printf("\n   *** MATRIX MULTIPLICATION BENCHMARK TEST ***\n\n");
   printf("RESULTS OF THE TEST:\n");
#endif
   Test(ArrayA, ArrayB, ResultArray);
}


void InitSeed(void)
/*
 * Initializes the seed used in the random number generator.
 */
{
  /* ***UPPSALA WCET***:
     changed Thomas Ls code to something simpler.
   Seed = KNOWN_VALUE - 1; */
  Seed = 0;
}


void Test(matrix A, matrix B, matrix Res)
/*
 * Runs a multiplication test on an array.  Calculates and prints the
 * time it takes to multiply the matrices.
 */
{
#ifndef UPPSALAWCET
   long StartTime, StopTime;
   float TotalTime;
#endif

   Initialize(A);
   Initialize(B);

   /* ***UPPSALA WCET***: don't print or time */
#ifndef UPPSALAWCET
   StartTime = ttime ();
#endif

   Multiply(A, B, Res);

   /* ***UPPSALA WCET***: don't print or time */
#ifndef UPPSALAWCET
   StopTime = ttime();
   TotalTime = (StopTime - StartTime) / 1000.0;
   printf("    - Size of array is %d\n", UPPERLIMIT);
   printf("    - Total multiplication time is %3.3f seconds\n\n", TotalTime);
#endif
}


void Initialize(matrix Array)
/*
 * Intializes the given array with random integers.
 */
{
   int OuterIndex, InnerIndex;

   for (OuterIndex = 0; OuterIndex < UPPERLIMIT; OuterIndex++)
      for (InnerIndex = 0; InnerIndex < UPPERLIMIT; InnerIndex++)
         Array[OuterIndex][InnerIndex] = RandomInteger();
}


int RandomInteger(void)
/*
 * Generates random integers between 0 and 8095
 */
{
   Seed = ((Seed * 133) + 81) % 8095;
   return (Seed);
}


#ifndef UPPSALAWCET
int ttime()
/*
 * This function returns in milliseconds the amount of compiler time
 * used prior to it being called.
 */
{
   struct tms buffer;
   int utime;

   /*   times(&buffer);   times not implemented */
   utime = (buffer.tms_utime / 60.0) * 1000.0;
   return (utime);
}
#endif

void Multiply(matrix A, matrix B, matrix Res)
/*
 * Multiplies arrays A and B and stores the result in ResultArray.
 */
{
   register int Outer, Inner, Index;

   for (Outer = 0; Outer < UPPERLIMIT; Outer++)
      for (Inner = 0; Inner < UPPERLIMIT; Inner++)
      {
         Res [Outer][Inner] = 0;
         for (Index = 0; Index < UPPERLIMIT; Index++)
            Res[Outer][Inner]  +=
               A[Outer][Index] * B[Index][Inner];
       }
}

---

---
[cdfg main]

**Parte 1 - Código Graphviz:**

```dot
digraph main {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: Seed\nC-Use: "];
    2 [label="2", xlabel="P-Use: ArrayA, ArrayB, ResultArray"];
    3 [label="3", xlabel="P-Use: ArrayA, ArrayB"];
    4 [label="4", xlabel="C-Use: RandomInteger()"];
    5 [label="5", xlabel="Def: ArrayA[], ArrayB[], ResultArray[]"];
    6 [label="6", xlabel="P-Use: A, B, Res"];
    7 [label="7", xlabel="C-Use: Multiply()];
    8 [label="8", xlabel="Def: StartTime, StopTime"];
    9 [label="9", xlabel="C-Use: TotalTime"];
    10[label="10", xlabel="P-Use: ArrayA, ArrayB, ResultArray"];
    
    1 -> 2;
    2 -> 3;
    3 -> 4;
    4 -> 5;
    5 -> 6;
    6 -> 7;
    7 -> 8;
    8 -> 9;
    9 -> 10;
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**

```codigos - main
Node 1:
void main()
{
   InitSeed();
---

Node 2:
Test(ArrayA, ArrayB, ResultArray);
}

Node 3:
Initialize(A);

Node 4:
Initialize(B);

Node 5:
StartTime = ttime();

Node 6:
Multiply(A, B, Res);

Node 7:
StopTime = ttime();

Node 8:
TotalTime = (StopTime - StartTime) / 1000.0;

Node 9:
return;
</codigos>
```

**Note:** The CDFG above is a simplified representation focusing on the control flow within `main()`. Each node represents a basic block, and edges show sequential execution. Data flow details are included in the node labels as per the specifications.
---

---
[analise infeasible_paths main]

```markdown
Nenhum caminho inviável foi identificado.
```

**Motivo:** O fluxo de controle na função `main` é linear sem nenhuma bifurcação ou condições que possam levar a caminhos inviáveis. Cada nó é executado sequencialmente, e não há contradições lógicas ou dependências de dados inconsistentes no contexto fornecido.
---

---
[cdfg InitSeed]

The Control and Data Flow Graph (CDFG) for the `InitSeed` function consists of two nodes. The first node represents the assignment of Seed to 0, and the second node is the exit point.

**Step-by-Step Explanation:**

1. **Function Analysis:** The `InitSeed` function initializes the global variable `Seed` to zero. It contains a single statement without any control flow structures (no loops or branches).

2. **Basic Blocks:** Since there's only one statement, it forms a single basic block.

3. **Data Flow:**
   - **Definition (Def):** The assignment `Seed = 0;` defines the variable `Seed`.
   - **Use (C-Use):** There are no computational uses of variables in this statement since the right-hand side is a constant.

4. **Control Flow:** The function starts at the assignment, then exits without any branches or loops.

5. **Graph Structure:**
   - Node 1 represents the assignment and includes the definition of `Seed`.
   - Node 2 is the exit node, represented as a double circle.

**CDFG Representation:**

```graphviz
digraph InitSeed {
    rankdir=TB;
    
    node [shape=circle];
    
    1 [label="1", xlabel="Def: Seed\nC-Use: None"];
    2 [label="", shape=doublecircle];
    
    1 -> 2;
}
```

**Mapping of Nodes to Code Lines:**

- **Node 1:** Line `Seed = 0;` → Defines `Seed`.
- **Node 2:** Exit point.

This graph accurately represents the control and data flow for the `InitSeed` function.
---

---
[analise infeasible_paths InitSeed]

# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.

---

**Passo 1: Mapeamento Código-CDFG**

- **Node 1**: Correspondente à linha do código `Seed = 0;`.
- **Node 2**: Ponto de saída da função, sem correspondência direta a uma linha de código.

**Passo 2: Identificação de Caminhos Potenciais**

O único caminho possível é:
- Nodo 1 → Nodo 2

**Passo 3: Classificação de Inviabilidade**

- **Caminho Viável**: O caminho único não apresenta nenhuma contradição lógica ou dependência de dados que possam torná-lo inviável.

**Passo 4: Análise de Viabilidade por Critério**

1. **Dados**: A variável `Seed` é inicializada adequadamente.
2. **Lógica**: Sem condições ou operações que possam gerar contradições.
3. **Contexto**: O comportamento da função não depende de estado externo.
4. **Loop**: Não há estruturas de loop presentes.

**Passo 5: Consolidação**

Como não há caminhos inviáveis, nenhuma entrada foi identificada para relatório.
---

---
[cdfg Test]

To solve this problem, we need to generate a Control and Data Flow Graph (CDFG) in Graphviz DOT format for the `Test` function provided. The function initializes two matrices, multiplies them, and measures the time taken for the multiplication. However, due to conditional compilation, certain parts related to timing and output are excluded when running under specific conditions.

### Approach
1. **Identify Functionality**: The `Test` function initializes matrices A and B, then calls the `Multiply` function with these matrices and another matrix Res.
2. **Basic Blocks**: Break down the function into basic blocks:
   - Initialization of matrix A.
   - Initialization of matrix B.
   - Multiplication of matrices A, B, and storing the result in Res.
3. **Data Flow Analysis**:
   - Track computational uses (C-Use) and definitions (Def) for each variable involved.
4. **Control Flow**: The function has a sequential control flow with no branches or loops.
5. **Graph Representation**: Represent each basic block as a node, and connect them with edges to show both control flow and data dependencies.

### Solution Code
```graphviz
digraph TestFunctionCDFG {
    node1 [label="Initialize(A)\nC-Use: A\nDef: A"];
    node2 [label="Initialize(B)\nC-Use: B\nDef: B"];
    node3 [label="Multiply(A,B,Res)\nC-Use: A, B, Res\nDef: Res"];

    // Control flow edges
    node1 -> node2;
    node2 -> node3;

    // Data flow edges (labeled with variable names)
    node1 -> node3 [label="A"];
    node2 -> node3 [label="B"];
}
```

### Explanation
- **Nodes**: Each node represents a basic block of the function:
  - `node1` initializes matrix A.
  - `node2` initializes matrix B.
  - `node3` multiplies matrices A, B, and stores the result in Res.
- **Control Flow Edges**: The arrows from `node1` to `node2` and `node2` to `node3` represent the sequential execution of the function.
- **Data Flow Edges**: Arrows labeled with variable names show dependencies between nodes:
  - Matrix A from `node1` is used in `node3`.
  - Matrix B from `node2` is used in `node3`.

This graph provides a clear visual representation of both the control flow and data dependencies within the `Test` function, facilitating understanding of its execution and variable usage.
---

---
[analise infeasible_paths Test]

```markdown
Nenhum caminho inviável foi identificado.
```
---

---
[cdfg Initialize]

```dot
digraph Initialize {
    rankdir=TB;
    
    1 [label="1", xlabel="Def: OuterIndex, InnerIndex\nC-Use: none"];
    2 [label="2", xlabel="P-Use: OuterIndex"];
    3 [label="3", shape=diamond];
    4 [label="4", shape=box];
    5 [label="5", shape=diamond];
    6 [label="6", shape=box];
    7 [label="7", shape=diamond];
    8 [label="8"];
    9 [label="9", shape=diamond];
    10 [label="10"];
    11 [label="11", shape=doublecircle];
    
    1 -> 2;
    2 -> 3 [label="True\n(OuterIndex < UPPERLIMIT)"];
    2 -> 8 [label="False"];
    3 -> 4 [label="True"];
    4 -> 5 [label="Def: OuterIndex++"];
    5 -> 6 [label="P-Use: InnerIndex"];
    6 -> 7 [label="Def: Array[Outer][Inner] = RandomInteger()"];
    7 -> 9 [label="True\n(InnerIndex < UPPERLIMIT)"];
    7 -> 8 [label="False"];
    8 -> 10;
    10 -> 2;
    
    /* Legend */
    node [shape=box, label="Processamento", xlabel="Operações básicas"];
    node [shape=diamond, label="Condição", xlabel="If/While"];
}
```

<codigos - Initialize>
Node 1:
void Initialize(matrix Array) {
   int OuterIndex, InnerIndex;
---
Node 2:
for (OuterIndex = 0; OuterIndex < UPPERLIMIT; OuterIndex++)
---
Node 3:
if (OuterIndex < UPPERLIMIT)
---
Node 4:
InnerIndex = 0
---
Node 5:
for (InnerIndex = 0; InnerIndex < UPPERLIMIT; InnerIndex++)
---
Node 6:
Array[OuterIndex][InnerIndex] = RandomInteger();
</codigos>
---

---
[analise infeasible_paths Initialize]

```markdown
Nenhum caminho inviável foi identificado.
```
---

---
[cdfg RandomInteger]

**Parte 1 - Código Graphviz:**

```dot
digraph RandomInteger {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: Seed"];
    2 [label="2", xlabel="Use: Seed"];
    3 [label="3", shape=doublecircle];
    
    1 -> 2 ;
    2 -> 3 ;
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**

<codigos - RandomInteger>
Node 1:
Seed = ((Seed * 133) + 81) % 8095;
---
Node 2:
return Seed;
</codigos>
---

---
[analise infeasible_paths RandomInteger]

```markdown
Nenhum caminho inviável foi identificado.
```
---

---
[cdfg Multiply]

To generate the Control and Data Flow Graph (CDFG) for the provided `Multiply` function in Graphviz DOT format, we first analyze the control flow and data usage within the nested loops. The CDFG captures both the sequence of operations and the dependencies between variables.

### Control Flow Graph Structure:
1. **Nodes** represent basic blocks or significant points in the code.
2. **Edges** represent control flows between nodes.
3. **Data Dependencies** are noted within each node where applicable.

The function's structure involves three nested loops without any conditional branches except for loop conditions, resulting in a straightforward yet nested control flow.

### CDFG in Graphviz DOT Format:
```dot
digraph Multiply_CDFG {
    node [shape=rectangle];
    Exit [shape=circle, label="", style=invis];
    
    0[label="Start"];
    1[label="for (Outer = 0;"];
    2[label="if (Outer < UPPERLIMIT)"];
    3[label="Outer++"];
    4[label="for (Inner = 0;"];
    5[label="if (Inner < UPPERLIMIT)"];
    6[label="Inner++"];
    7[label="Res[Outer][Inner] = 0;"];
    8[label="for (Index = 0;"];
    9[label="if (Index < UPPERLIMIT)"];
    10[label="Res[O][I] += A[O][Index] * B[Index][I];"];
    11[label="Index++"];

    0 -> 1;
    1 -> 2;
    2 -> 3 [label="true"];
    2 -> Exit [label="false"];
    3 -> 4;
    4 -> 5;
    5 -> 6 [label="true"];
    5 -> 3 [label="false"];
    6 -> 7;
    7 -> 8;
    8 -> 9;
    9 -> 10 [label="true"];
    9 -> 5 [label="false"];
    10 -> 11;
    11 -> 9;
}
```

### Explanation:
- **Nodes**: Each node represents a specific operation or loop condition. For example, `2` is the outermost loop's condition check.
- **Edges**: Directed edges show control flow. A true edge (labeled "true") indicates the loop continues; a false edge leads to termination (`Exit`).
- **Data Dependencies**: Not explicitly shown but inferred where variables like `Outer`, `Inner`, and `Index` are used.

This CDFG accurately represents the nested loops' structure and control flow, ensuring clarity in understanding the function's execution.
---

---
[analise infeasible_paths Multiply]

Nenhum caminho inviável foi identificado.
---

---
**Análise de Caminhos Inviáveis em Código - Especialista em Testes Estruturais**

**Instruções de Entrada:**  
Forneça:  
1. O código-fonte a ser analisado  
2. Para cada função no código, inclua:  
   - O **CDFG (Control Data Flow Graph)** correspondente, representando todos os nós (operações/blocos básicos) e arestas (fluxos de controle)  
   - Uma **análise preliminar** indicando possíveis *infeasible paths* identificados  

---

**Processo de Análise (Executado Automaticamente):**  

**1. Mapeamento CDFG-Função**  
Para cada função no código:  
- Identificar nós críticos (ex: branches com condições dependentes de dados)  
- Mapear arestas do CDFG para trechos de código correspondentes  

**2. Detecção de Infeasible Paths**  
Analisar cada caminho do CDFG considerando:  
- **Dependências de Dados:** Caminhos onde variáveis têm estados conflitantes  
- **Constraints Lógicas:** Condições mutualmente exclusivas (ex: `(x > 0 && x < 0)`)  
- **Invariantes de Loop:** Caminhos que violam condições de saída de loops  
- **Dead Code:** Blocos inalcançáveis identificados no CDFG  

**3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**4. Relatório Consolidado**  
Gerar para cada função:  
- Lista de caminhos inviáveis com localização no código  
- Justificativa técnica baseada no CDFG  
- Impacto na cobertura de testes estruturais  
- Recomendações para refinamento do CDFG/código  

---

**Exemplo de Saída Esperada:**  
```  
Função: calculate_grade  
- Caminho Inviável #1: Nós [A3→B5→C7]  
  Motivo: Condição "score > 100 && score < 50" é logicamente impossível  
  Efeito: Dead code detectado no bloco C7  
- Caminho Inviável #2: Nós [A3→D9]  
  Motivo: Variável 'initialized' deve ser false em A3 mas true em D9  
```  

**Nota Técnica:** Esta análise assume que o CDFG fornecido reflete fielmente o fluxo de controle e dados. Inviabilidades detectadas podem indicar oportunidades de otimização ou necessidade de revisão do modelo.
---
