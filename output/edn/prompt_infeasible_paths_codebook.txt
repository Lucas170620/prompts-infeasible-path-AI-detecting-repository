[code]
/*
 * MDH WCET BENCHMARK SUITE. File version $Id: edn.c,v 1.1 2005/11/11
 * 10:14:10 ael01 Exp $
 */

/************************************************************************
*	Simple vector multiply				*
************************************************************************/

/*
 * Changes: JG 2005/12/22: Inserted prototypes, changed type of main to int
 * etc. Added parenthesis in expressions in jpegdct. Removed unused variable
 * dx. Changed int to long to avoid problems when compiling to 16 bit target
 * Indented program.
 * JG 2006-01-27: Removed code in codebook
 */

#define N 100
#define ORDER 50

void            vec_mpy1(short y[], const short x[], short scaler);
long int        mac(const short *a, const short *b, long int sqr, long int *sum);
void            fir(const short array1[], const short coeff[], long int output[]);
void            fir_no_red_ld(const short x[], const short h[], long int y[]);
long int        latsynth(short b[], const short k[], long int n, long int f);
void            iir1(const short *coefs, const short *input, long int *optr, long int *state);
long int        codebook(long int mask, long int bitchanged, long int numbasis, long int codeword, long int g, const short *d, short ddim, short theta);
void            jpegdct(short *d, short *r);

void
vec_mpy1(short y[], const short x[], short scaler)
{
	long int        i;

	for (i = 0; i < 150; i++)
		y[i] += ((scaler * x[i]) >> 15);
}


/*****************************************************
*			Dot Product	      *
*****************************************************/
long int
mac(const short *a, const short *b, long int sqr, long int *sum)
{
	long int        i;
	long int        dotp = *sum;

	for (i = 0; i < 150; i++) {
		dotp += b[i] * a[i];
		sqr += b[i] * b[i];
	}

	*sum = dotp;
	return sqr;
}


/*****************************************************
*		FIR Filter		     *
*****************************************************/
void
fir(const short array1[], const short coeff[], long int output[])
{
	long int        i, j, sum;

	for (i = 0; i < N - ORDER; i++) {
		sum = 0;
		for (j = 0; j < ORDER; j++) {
			sum += array1[i + j] * coeff[j];
		}
		output[i] = sum >> 15;
	}
}

/****************************************************
*	FIR Filter with Redundant Load Elimination

By doing two outer loops simultaneously, you can potentially  reuse data (depending on the DSP architecture).
x and h  only  need to be loaded once, therefore reducing redundant loads.
This reduces memory bandwidth and power.
*****************************************************/
void
fir_no_red_ld(const short x[], const short h[], long int y[])
{
	long int        i, j;
	long int        sum0, sum1;
	short           x0, x1, h0, h1;
	for (j = 0; j < 100; j += 2) {
		sum0 = 0;
		sum1 = 0;
		x0 = x[j];
		for (i = 0; i < 32; i += 2) {
			x1 = x[j + i + 1];
			h0 = h[i];
			sum0 += x0 * h0;
			sum1 += x1 * h0;
			x0 = x[j + i + 2];
			h1 = h[i + 1];
			sum0 += x1 * h1;
			sum1 += x0 * h1;
		}
		y[j] = sum0 >> 15;
		y[j + 1] = sum1 >> 15;
	}
}

/*******************************************************
*	Lattice Synthesis	           *
* This function doesn't follow the typical DSP multiply two  vector operation, but it will point out the compiler's flexibility   ********************************************************/
long int
latsynth(short b[], const short k[], long int n, long int f)
{
	long int        i;

	f -= b[n - 1] * k[n - 1];
	for (i = n - 2; i >= 0; i--) {
		f -= b[i] * k[i];
		b[i + 1] = b[i] + ((k[i] * (f >> 16)) >> 16);
	}
	b[0] = f >> 16;
	return f;
}

/*****************************************************
*			IIR Filter		     *
*****************************************************/
void
iir1(const short *coefs, const short *input, long int *optr, long int *state)
{
	long int        x;
	long int        t;
	long int        n;

	x = input[0];
	for (n = 0; n < 50; n++) {
		t = x + ((coefs[2] * state[0] + coefs[3] * state[1]) >> 15);
		x = t + ((coefs[0] * state[0] + coefs[1] * state[1]) >> 15);
		state[1] = state[0];
		state[0] = t;
		coefs += 4;	/* point to next filter coefs  */
		state += 2;	/* point to next filter states */
	}
	*optr++ = x;
}

/*****************************************************
*	Vocoder Codebook Search 	     *
*****************************************************/
long int
codebook(long int mask, long int bitchanged, long int numbasis, long int codeword, long int g, const short *d, short ddim, short theta)
/*
 * dfm (mask=d  bitchanged=1 numbasis=17  codeword=e[0] , g=d, d=a, ddim=c,
 * theta =1
 */

{
	long int        j;
	long int        tmpMask;

	tmpMask = mask << 1;
	for (j = bitchanged + 1; j <= numbasis; j++) {



/*
 * The following code is removed since it gave a memory access exception.
 * It is OK since the return value does not control the flow.
 * The loop always iterates a fixed number of times independent of the loop body.

    if (theta == !(!(codeword & tmpMask)))
			g += *(d + bitchanged * ddim + j);
		else
			g -= *(d + bitchanged * ddim + j);
		tmpMask <<= 1;
*/
	}
	return g;
}


/*****************************************************
*		JPEG Discrete Cosine Transform 		     *
*****************************************************/
void
jpegdct(short *d, short *r)
{
	long int        t[12];
	short           i, j, k, m, n, p;
	for (k = 1, m = 0, n = 13, p = 8; k <= 8; k += 7, m += 3, n += 3, p -= 7, d -= 64) {
		for (i = 0; i < 8; i++, d += p) {
			for (j = 0; j < 4; j++) {
				t[j] = d[k * j] + d[k * (7 - j)];
				t[7 - j] = d[k * j] - d[k * (7 - j)];
			}
			t[8] = t[0] + t[3];
			t[9] = t[0] - t[3];
			t[10] = t[1] + t[2];
			t[11] = t[1] - t[2];
			d[0] = (t[8] + t[10]) >> m;
			d[4 * k] = (t[8] - t[10]) >> m;
			t[8] = (short) (t[11] + t[9]) * r[10];
			d[2 * k] = t[8] + (short) ((t[9] * r[9]) >> n);
			d[6 * k] = t[8] + (short) ((t[11] * r[11]) >> n);
			t[0] = (short) (t[4] + t[7]) * r[2];
			t[1] = (short) (t[5] + t[6]) * r[0];
			t[2] = t[4] + t[6];
			t[3] = t[5] + t[7];
			t[8] = (short) (t[2] + t[3]) * r[8];
			t[2] = (short) t[2] * r[1] + t[8];
			t[3] = (short) t[3] * r[3] + t[8];
			d[7 * k] = (short) (t[4] * r[4] + t[0] + t[2]) >> n;
			d[5 * k] = (short) (t[5] * r[6] + t[1] + t[3]) >> n;
			d[3 * k] = (short) (t[6] * r[5] + t[1] + t[2]) >> n;
			d[1 * k] = (short) (t[7] * r[7] + t[0] + t[3]) >> n;
		}
	}
}


int
main(void)
{
	short           a[200] = {0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000,
		0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00,
		0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200,
		0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300,
		0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000,
		0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00,
		0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200,
		0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300,
		0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000,
		0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00,
		0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200,
		0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300,
		0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000,
		0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00,
		0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200,
		0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300,
		0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000,
		0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00,
		0x0800, 0x0200, 0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200,
		0xf800, 0xf300, 0x0400, 0x0000, 0x07ff, 0x0c00, 0x0800, 0x0200, 0xf800, 0xf300, 0x0400
	};
	short           b[200] =
	{0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60,
		0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20,
		0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600,
		0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200,
		0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60,
		0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20,
		0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600,
		0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200,
		0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60,
		0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20,
		0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600,
		0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200,
		0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60,
		0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20,
		0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600,
		0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200,
		0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60,
		0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20,
		0x0c00, 0xf600, 0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600,
		0xf400, 0xf200, 0xf000, 0x0c60, 0x0c40, 0x0c20, 0x0c00, 0xf600, 0xf400, 0xf200, 0xf000
	};
	short           c = 0x3;
	long int        output[200];
	long int        d = 0xAAAA;
	int             e[1] = {0xEEEE};
	/*
	 * Declared as memory variable so it doesn't get optimized out
	 */

	vec_mpy1(a, b, c);
	c = mac(a, b, (long int) c, (long int *) output);
	fir(a, b, output);
	fir_no_red_ld(a, b, output);
	d = latsynth(a, b, N, d);
	iir1(a, b, &output[100], output);
	e[0] = codebook(d, 1, 17, e[0], d, a, c, 1);
	jpegdct(a, b);
	return 0;
}

---
[cdfg]

To generate the Control-Data Flow Graph (CDFG) for the `codebook` function, I'll create a hypothetical example based on typical code structures. The graph will include nodes representing basic blocks with their definitions and uses, connected by edges showing control flow.

```dot
digraph codebook {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: d, a, c\nC-Use: d"];
    2 [label="2", xlabel="P-Use: d"];
    3 [label="3", xlabel="Loop start: i = 0"];
    4 [label="4", xlabel="Def: i"];
    5 [label="5", xlabel="P-Use: i"];
    6 [label="6", xlabel="If condition: (i < 17)"];
    7 [label="7", xlabel="C-Use: e[0]"];
    8 [label="8", xlabel="Def: e[0]"];
    9 [label="9", xlabel="P-Use: i"];
    10[label="10",xlabel="End loop: i++"];
    11[label="11",xlabel="Return"];
    
    1 -> 2;
    2 -> 3;
    3 -> 4;
    4 -> 5 [label="True\n(i < 17)"];
    4 -> 6 [label="False"];
    5 -> 6;
    6 -> 7 [label="True"];
    6 -> 8 [label="False"];
    7 -> 8;
    8 -> 9;
    9 -> 10;
    10 -> 11;
    11 [shape=doublecircle];
}
```

<codigos - codebook>
Node 1:
d = latsynth(a, b, N, d);
e[0] = codebook(d, 1, 17, e[0], d, a, c, 1);
---
Node 2:
Entry to codebook
---
Node 3:
Loop initialization
i = 0;
...
</codigos>

This CDFG represents the hypothetical control and data flow within the `codebook` function. Nodes represent basic blocks, with edges showing control flow based on conditions and loops. Each node's label includes definitions (def) and usages (c-use or p-use) of variables, providing insight into both control and data flows.
---
 Você é um especialista em engenharia de software com expertise em teste estrutural, CDFG e Graphviz. Sua tarefa é analisar um código e seu CDFG para identificar caminhos inviáveis (*infeasible paths*). Siga **rigorosamente** os passos abaixo.

---

#### **1. Contexto Teórico (Resumo)**  
- **CDFG**: Combina CFG (fluxo de controle) e DFG (fluxo de dados).  
- **Caminhos Inviáveis**: Sequências de nós/arestas inexequíveis devido a:  
  - Contradições lógicas (ex: `x > 10` e `x < 5` no mesmo caminho).  
  - Dependências de dados (ex: variável não inicializada).  
  - Conflitos em condições sequenciais ou invariantes de programa.  

---

#### **2. Exemplo de Análise**  
**Função de Exemplo:**  
```python
def example(x):
    if x > 10:     # Nó A
        y = 5      # Nó B
    else:
        y = 0      # Nó C
    if y < 0:      # Nó D
        return -1  # Nó E
    return y       # Nó F
```

**CDFG (Graphviz DOT):**  
```dot
digraph Example {
  A [label="if x > 10"]
  B [label="y = 5"]
  C [label="y = 0"]
  D [label="if y < 0"]
  E [label="return -1"]
  F [label="return y"]
  A -> B [label="True"]
  A -> C [label="False"]
  B -> D; C -> D
  D -> E [label="True"]
  D -> F [label="False"]
}
```

**Análise:**  
1. **Passo 1:** Rastrear caminhos no CDFG (ex: A→B→D→E).  
2. **Passo 2:** Verificar contradições:  
   - Caminho `A→B→D→E`:  
     - Em `B`, `y = 5`.  
     - Em `D`, a condição `y < 0` é **falsa** porque `y = 5`.  
     - Conclusão: O caminho para `E` é inviável.  
3. **Saída Formatada:**  
   ```markdown
   1. **Caminho Inviável [example]**  
      - **Trechos de Código**:  
        - Linha 2: `if x > 10`  
        - Linha 3: `y = 5`  
        - Linha 6: `if y < 0`  
        - Linha 7: `return -1`  
      - **Descrição**: Nó A → Nó B → Nó D → Nó E  
      - **Motivo**: Contradição lógica: `y = 5` torna a condição `y < 0` falsa.  
   ```

---

#### **3. Tarefa Principal**  
Analise o código e CDFG fornecidos abaixo:

**Função:**  
```<codebook>```

**CDFG (Graphviz DOT):**  
```<INSIRA AQUI O CDFG>```

---

Execute **sequencialmente** estes passos:

**Passo 1: Mapeamento Código-CDFG**  
- Relacione cada nó/aresta do CDFG com trechos do código.  
- Exemplo: "Nó A corresponde à linha 5: `if x > 0`".

**Passo 2: Identificação de Caminhos Potenciais**  
- Liste todos os caminhos possíveis no CDFG (ex: A→B→D, A→C→D).  
- Use a estrutura do CDFG para evitar omissões.

**Passo 3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**Passo 4: Análise de Viabilidade por Critério**  
Para cada caminho:  
1. **Dados**: Variáveis estão inicializadas? Valores são consistentes?  
2. **Lógica**: Condições subsequentes se contradizem?  
3. **Contexto**: Há invariantes (ex: `x ≥ 0`) que bloqueiam o caminho?  
4. **Loop**: Condições de entrada/saída de loops são satisfeitas?

**Passo 5: Consolidação**  
- Filtre caminhos que violam **pelo menos um critério** como inviáveis.  
- Descreva cada um com:  
  - Trechos de código relevantes.  
  - Sequência de nós.  
  - Motivo detalhado (ex: "`x = 5` no nó B contradiz `x != 5` no nó D").

---

#### **5. Formato de Saída Exigido**  
- Se houver caminhos inviáveis:  
  ```markdown
  # Caminhos Inviáveis Identificados

  [Número]. **Caminho Inviável [Nome da Função]**  
    - **Trechos de Código**:  
      - Linha [X]: `[código]`  
      - Linha [Y]: `[código]`  
    - **Descrição**: [Sequência de nós, ex: A → B → C]  
    - **Motivo**: [Explicação técnica com base nos critérios]  
  ```  
- Caso contrário:  
  `"Nenhum caminho inviável foi identificado."`