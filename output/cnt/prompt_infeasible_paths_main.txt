[code]
/* $Id: cnt.c,v 1.3 2005/04/04 11:34:58 csg Exp $ */



/* sumcntmatrix.c */



//#include <sys/types.h>

//#include <sys/times.h>



// #define WORSTCASE 1

// #define MAXSIZE 100 Changed JG/Ebbe

#define MAXSIZE 10



// Typedefs

typedef int matrix [MAXSIZE][MAXSIZE];



// Forwards declarations

int main(void);

int Test(matrix);

int Initialize(matrix);

int InitSeed(void);

void Sum(matrix);

int RandomInteger(void);



// Globals

int Seed;

matrix Array;

int Postotal, Negtotal, Poscnt, Negcnt;



// The main function

int main (void)

{

   InitSeed();

   //printf("\n   *** MATRIX SUM AND COUNT BENCHMARK TEST ***\n\n");

   //printf("RESULTS OF THE TEST:\n");

   Test(Array);

   return 1;

}





int Test(matrix Array)

{

   long StartTime, StopTime;

   float TotalTime;



   Initialize(Array);

   StartTime = 1000.0; //ttime();

   Sum(Array);

   StopTime = 1500.0; //ttime();



   TotalTime = (StopTime - StartTime) / 1000.0;



   //printf("    - Size of array is %d\n", MAXSIZE);

   //printf("    - Num pos was %d and Sum was %d\n", Poscnt, Postotal);

   //printf("    - Num neg was %d and Sum was %d\n", Negcnt, Negtotal);

   //printf("    - Num neg was %d\n", Negcnt);

   //printf("    - Total sum time is %3.3f seconds\n\n", TotalTime);

   return 0;

}





// Intializes the given array with random integers.

int Initialize(matrix Array)

{

   register int OuterIndex, InnerIndex;



   for (OuterIndex = 0; OuterIndex < MAXSIZE; OuterIndex++) //100 + 1

      for (InnerIndex = 0; InnerIndex < MAXSIZE; InnerIndex++) //100 + 1

         Array[OuterIndex][InnerIndex] = RandomInteger();



   return 0;

}





// Initializes the seed used in the random number generator.

int InitSeed (void)

{

   Seed = 0;

   return 0;

}



void Sum(matrix Array)

{

  register int Outer, Inner;



  int Ptotal = 0; /* changed these to locals in order to drive worst case */

  int Ntotal = 0;

  int Pcnt = 0;

  int Ncnt = 0;



  for (Outer = 0; Outer < MAXSIZE; Outer++) //Maxsize = 100

    for (Inner = 0; Inner < MAXSIZE; Inner++)

#ifdef WORSTCASE

      if (Array[Outer][Inner] >= 0) {

#else

	if (Array[Outer][Inner] < 0) {

#endif

	  Ptotal += Array[Outer][Inner];

	  Pcnt++;

	}

	else {

	  Ntotal += Array[Outer][Inner];

	  Ncnt++;

	}



  Postotal = Ptotal;

  Poscnt = Pcnt;

  Negtotal = Ntotal;

  Negcnt = Ncnt;

}





// This function returns in milliseconds the amount of compiler time

//int ttime()

//{

//  struct tms buffer;

//int utime;



//times(&buffer);

//utime = (buffer.tms_utime / 60.0) * 1000.0;

//return (utime);

//}





// Generates random integers between 0 and 8095

int RandomInteger(void)

{

   Seed = ((Seed * 133) + 81) % 8095;

   return Seed;

}

---
[cdfg]

**Parte 1 - Código Graphviz:**

```dot
digraph main {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="InitSeed()", xlabel="Def: Seed"];
    2 [label="Test(Array)", xlabel="Use: Array"];
    3 [label="return 1", xlabel="Def: return value"];
    4 [shape=doublecircle, label="End of main()"];
    
    1 -> 2;
    2 -> 3;
    3 -> 4;
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**

<codigos - main>
Node 1:
InitSeed();
---
Node 2:
Test(Array);
---
Node 3:
return 1;
</codigos>
---
 Você é um especialista em engenharia de software com expertise em teste estrutural, CDFG e Graphviz. Sua tarefa é analisar um código e seu CDFG para identificar caminhos inviáveis (*infeasible paths*). Siga **rigorosamente** os passos abaixo.

---

#### **1. Contexto Teórico (Resumo)**  
- **CDFG**: Combina CFG (fluxo de controle) e DFG (fluxo de dados).  
- **Caminhos Inviáveis**: Sequências de nós/arestas inexequíveis devido a:  
  - Contradições lógicas (ex: `x > 10` e `x < 5` no mesmo caminho).  
  - Dependências de dados (ex: variável não inicializada).  
  - Conflitos em condições sequenciais ou invariantes de programa.  

---

#### **2. Exemplo de Análise**  
**Função de Exemplo:**  
```python
def example(x):
    if x > 10:     # Nó A
        y = 5      # Nó B
    else:
        y = 0      # Nó C
    if y < 0:      # Nó D
        return -1  # Nó E
    return y       # Nó F
```

**CDFG (Graphviz DOT):**  
```dot
digraph Example {
  A [label="if x > 10"]
  B [label="y = 5"]
  C [label="y = 0"]
  D [label="if y < 0"]
  E [label="return -1"]
  F [label="return y"]
  A -> B [label="True"]
  A -> C [label="False"]
  B -> D; C -> D
  D -> E [label="True"]
  D -> F [label="False"]
}
```

**Análise:**  
1. **Passo 1:** Rastrear caminhos no CDFG (ex: A→B→D→E).  
2. **Passo 2:** Verificar contradições:  
   - Caminho `A→B→D→E`:  
     - Em `B`, `y = 5`.  
     - Em `D`, a condição `y < 0` é **falsa** porque `y = 5`.  
     - Conclusão: O caminho para `E` é inviável.  
3. **Saída Formatada:**  
   ```markdown
   1. **Caminho Inviável [example]**  
      - **Trechos de Código**:  
        - Linha 2: `if x > 10`  
        - Linha 3: `y = 5`  
        - Linha 6: `if y < 0`  
        - Linha 7: `return -1`  
      - **Descrição**: Nó A → Nó B → Nó D → Nó E  
      - **Motivo**: Contradição lógica: `y = 5` torna a condição `y < 0` falsa.  
   ```

---

#### **3. Tarefa Principal**  
Analise o código e CDFG fornecidos abaixo:

**Função:**  
```<main>```

**CDFG (Graphviz DOT):**  
```<INSIRA AQUI O CDFG>```

---

Execute **sequencialmente** estes passos:

**Passo 1: Mapeamento Código-CDFG**  
- Relacione cada nó/aresta do CDFG com trechos do código.  
- Exemplo: "Nó A corresponde à linha 5: `if x > 0`".

**Passo 2: Identificação de Caminhos Potenciais**  
- Liste todos os caminhos possíveis no CDFG (ex: A→B→D, A→C→D).  
- Use a estrutura do CDFG para evitar omissões.

**Passo 3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**Passo 4: Análise de Viabilidade por Critério**  
Para cada caminho:  
1. **Dados**: Variáveis estão inicializadas? Valores são consistentes?  
2. **Lógica**: Condições subsequentes se contradizem?  
3. **Contexto**: Há invariantes (ex: `x ≥ 0`) que bloqueiam o caminho?  
4. **Loop**: Condições de entrada/saída de loops são satisfeitas?

**Passo 5: Consolidação**  
- Filtre caminhos que violam **pelo menos um critério** como inviáveis.  
- Descreva cada um com:  
  - Trechos de código relevantes.  
  - Sequência de nós.  
  - Motivo detalhado (ex: "`x = 5` no nó B contradiz `x != 5` no nó D").

---

#### **5. Formato de Saída Exigido**  
- Se houver caminhos inviáveis:  
  ```markdown
  # Caminhos Inviáveis Identificados

  [Número]. **Caminho Inviável [Nome da Função]**  
    - **Trechos de Código**:  
      - Linha [X]: `[código]`  
      - Linha [Y]: `[código]`  
    - **Descrição**: [Sequência de nós, ex: A → B → C]  
    - **Motivo**: [Explicação técnica com base nos critérios]  
  ```  
- Caso contrário:  
  `"Nenhum caminho inviável foi identificado."`