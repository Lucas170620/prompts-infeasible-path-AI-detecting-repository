[code]
/* $Id: cnt.c,v 1.3 2005/04/04 11:34:58 csg Exp $ */



/* sumcntmatrix.c */



//#include <sys/types.h>

//#include <sys/times.h>



// #define WORSTCASE 1

// #define MAXSIZE 100 Changed JG/Ebbe

#define MAXSIZE 10



// Typedefs

typedef int matrix [MAXSIZE][MAXSIZE];



// Forwards declarations

int main(void);

int Test(matrix);

int Initialize(matrix);

int InitSeed(void);

void Sum(matrix);

int RandomInteger(void);



// Globals

int Seed;

matrix Array;

int Postotal, Negtotal, Poscnt, Negcnt;



// The main function

int main (void)

{

   InitSeed();

   //printf("\n   *** MATRIX SUM AND COUNT BENCHMARK TEST ***\n\n");

   //printf("RESULTS OF THE TEST:\n");

   Test(Array);

   return 1;

}





int Test(matrix Array)

{

   long StartTime, StopTime;

   float TotalTime;



   Initialize(Array);

   StartTime = 1000.0; //ttime();

   Sum(Array);

   StopTime = 1500.0; //ttime();



   TotalTime = (StopTime - StartTime) / 1000.0;



   //printf("    - Size of array is %d\n", MAXSIZE);

   //printf("    - Num pos was %d and Sum was %d\n", Poscnt, Postotal);

   //printf("    - Num neg was %d and Sum was %d\n", Negcnt, Negtotal);

   //printf("    - Num neg was %d\n", Negcnt);

   //printf("    - Total sum time is %3.3f seconds\n\n", TotalTime);

   return 0;

}





// Intializes the given array with random integers.

int Initialize(matrix Array)

{

   register int OuterIndex, InnerIndex;



   for (OuterIndex = 0; OuterIndex < MAXSIZE; OuterIndex++) //100 + 1

      for (InnerIndex = 0; InnerIndex < MAXSIZE; InnerIndex++) //100 + 1

         Array[OuterIndex][InnerIndex] = RandomInteger();



   return 0;

}





// Initializes the seed used in the random number generator.

int InitSeed (void)

{

   Seed = 0;

   return 0;

}



void Sum(matrix Array)

{

  register int Outer, Inner;



  int Ptotal = 0; /* changed these to locals in order to drive worst case */

  int Ntotal = 0;

  int Pcnt = 0;

  int Ncnt = 0;



  for (Outer = 0; Outer < MAXSIZE; Outer++) //Maxsize = 100

    for (Inner = 0; Inner < MAXSIZE; Inner++)

#ifdef WORSTCASE

      if (Array[Outer][Inner] >= 0) {

#else

	if (Array[Outer][Inner] < 0) {

#endif

	  Ptotal += Array[Outer][Inner];

	  Pcnt++;

	}

	else {

	  Ntotal += Array[Outer][Inner];

	  Ncnt++;

	}



  Postotal = Ptotal;

  Poscnt = Pcnt;

  Negtotal = Ntotal;

  Negcnt = Ncnt;

}





// This function returns in milliseconds the amount of compiler time

//int ttime()

//{

//  struct tms buffer;

//int utime;



//times(&buffer);

//utime = (buffer.tms_utime / 60.0) * 1000.0;

//return (utime);

//}





// Generates random integers between 0 and 8095

int RandomInteger(void)

{

   Seed = ((Seed * 133) + 81) % 8095;

   return Seed;

}

---

---
[cdfg main]

**Parte 1 - Código Graphviz:**

```dot
digraph main {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="InitSeed()", xlabel="Def: Seed"];
    2 [label="Test(Array)", xlabel="Use: Array"];
    3 [label="return 1", xlabel="Def: return value"];
    4 [shape=doublecircle, label="End of main()"];
    
    1 -> 2;
    2 -> 3;
    3 -> 4;
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**

<codigos - main>
Node 1:
InitSeed();
---
Node 2:
Test(Array);
---
Node 3:
return 1;
</codigos>
---

---
[analise infeasible_paths main]

# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.
---

---
[cdfg Test]

**Parte 1 - Código Graphviz:**

```dot
digraph Test {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: StartTime, StopTime, TotalTime"];
    2 [label="2", xlabel="C-Use: Array"];
    3 [label="3"];
    4 [label="4", xlabel="P-Use: Array"];
    5 [label="5", xlabel="Def: StartTime"];
    6 [label="6", xlabel="Def: StopTime"];
    7 [label="7", xlabel="C-Use: StartTime, StopTime"];
    8 [label="8", xlabel="Def: TotalTime"];
    9 [label="9", xlabel="Return"];
    
    1 -> 2 ;
    2 -> 3 ;
    3 -> 4 ;
    4 -> 5 ;
    5 -> 6 ;
    6 -> 7 ;
    7 -> 8 ;
    8 -> 9 ;
    9 [shape=doublecircle];
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**

<codigos - Test>
Node 1:
long StartTime, StopTime;
float TotalTime;
---
Node 2:
Initialize(Array);
---
Node 3:
StartTime = 1000.0; 
---
Node 4:
Sum(Array);
---
Node 5:
StopTime = 1500.0; 
---
Node 6:
TotalTime = (StopTime - StartTime) / 1000.0;
---
Node 7:
return 0;
</codigos>
---

---
[analise infeasible_paths Test]

# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.
---

---
[cdfg Initialize]

To construct the Control Flow Graph (CFG) for the given function `InitializeMatrix()`, we'll break down each step of the code into individual nodes and define their respective data flow properties.

### Function Code:
```c
void InitializeMatrix(int size) {
    int OuterIndex, InnerIndex;
    
    for (OuterIndex = 0; OuterIndex < size; OuterIndex++) {
        for (InnerIndex = 0; InnerIndex < size; InnerIndex++) {
            Matrix[OuterIndex][InnerIndex] = RandomInteger();
        }
    }
}
```

### CFG Construction:

1. **Node 1: Entry Point**
   - Represents the start of the function.
   
2. **Node 2: Initialize Outer Loop Variable**
   ```c
   OuterIndex = 0;
   ```
   - **Use:** None
   - **Def:** `OuterIndex`

3. **Node 3: Check Outer Loop Condition**
   ```c
   if (OuterIndex < size)
   ```
   - **Use:** `OuterIndex`
   
4. **Node 4: Initialize Inner Loop Variable**
   ```c
   InnerIndex = 0;
   ```
   - **Use:** None
   - **Def:** `InnerIndex`

5. **Node 5: Check Inner Loop Condition**
   ```c
   if (InnerIndex < size)
   ```
   - **Use:** `InnerIndex`
   
6. **Node 6: Call RandomInteger()**
   ```c
   value = RandomInteger();
   ```
   - **Use:** None
   - **Def:** `value` (the result from the function call)

7. **Node 7: Assign Value to Matrix Element**
   ```c
   Matrix[OuterIndex][InnerIndex] = value;
   ```
   - **Use:** `Matrix`, `OuterIndex`, `InnerIndex`
   - **Def:** The specific element in `Matrix`

8. **Node 8: Increment Inner Index**
   ```c
   InnerIndex++;
   ```
   - **Use:** `InnerIndex`
   - **Def:** `InnerIndex`

9. **Node 9: Exit Inner Loop (False Condition)**
   - Represents exiting the inner loop when condition is false.

10. **Node 10: Increment Outer Index**
    ```c
    OuterIndex++;
    ```
    - **Use:** `OuterIndex`
    - **Def:** `OuterIndex`

11. **Node 11: Exit Function (Return)**
    ```c
    return;
    ```
    - Represents the end of the function.

### Control Flow Edges:
- **Edges from Node 3**:
  - If condition is true, proceed to Node 4.
  - If false, move to Node 9 (exit function).
  
- **Edge from Node 5**:
  - If true, proceed to Node 6.
  - If false, go to Node 10 (increment OuterIndex) and then back to Node 3.

### Data Flow Summary:
- **Definitions** (`Def`):
  - Node 2: `OuterIndex`
  - Node 4: `InnerIndex`
  - Node 6: `value`
  - Node 7: Specific element in `Matrix`
  - Node 8: `InnerIndex`
  - Node 10: `OuterIndex`

- **Uses** (`Use`):
  - Node 3: `OuterIndex`
  - Node 5: `InnerIndex`
  - Node 7: `Matrix`, `OuterIndex`, `InnerIndex`
  
This CFG accurately represents the control and data flow of the function, showing each step in the nested loop structure and how variables are defined and used throughout.
---

---
[analise infeasible_paths Initialize]

```markdown
Nenhum caminho inviável foi identificado.
```

**Razão:** O código é estruturado de forma que todas as condições e loops são lógicos e consistentes. Não há contradições ou dependências de dados que possam tornar um caminho infeásivel.
---

---
[cdfg InitSeed]

**Parte 1 - Código Graphviz:**

```dot
digraph InitSeed {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: Seed\nC-Use: none"];
    2 [label="2", shape=doublecircle, xlabel="Return"];

    1 -> 2;
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**

<codigos - InitSeed>
Node 1:
Seed = 0;
---
Node 2:
return 0;
</codigos>
---

---
[analise infeasible_paths InitSeed]

# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.
---

---
[cdfg Sum]

```dot
digraph Sum {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: Ptotal, Ntotal, Pcnt, Ncnt"];
    2 [label="2", xlabel="Linha 3"];
    3 [label="3", xlabel="Linha 4"];
    4 [label="4", xlabel="Outer=0"];
    5 [label="5", xlabel="Inner=0"];
    6 [label="6", xlabel="Array[Outer][Inner]"];
    7 [label="7", xlabel="Condição: Array >=0"];
    8 [label="8", xlabel="Ptotal += Array[...], Pcnt++"];
    9 [label="9", xlabel="Ntotal += Array[...], Ncnt++"];
    10 [label="10", xlabel="Linha 7"];
    11 [label="11", xlabel="Inner++"];
    12 [label="12", xlabel="Inner < MAXSIZE"];
    13 [label="13", xlabel="Linha 5"];
    14 [label="14", xlabel="Outer++"];
    15 [label="15", xlabel="Outer < MAXSIZE"];
    16 [label="16", xlabel="Atribuição global"];
    17 [label="17", shape=doublecircle];
    
    1 -> 2;
    2 -> 4 [label="Inicio do loop Outer"];
    4 -> 5 [label="Outer inicializado"];
    5 -> 6;
    6 -> 7;
    7 -> 8 [label="Verdadeiro (WORSTCASE)"];
    7 -> 9 [label="Falso"];
    8 -> 10;
    9 -> 10;
    10 -> 11;
    11 -> 12 [label="Inner++];
    12 -> 5 [label="Inner < MAXSIZE"];
    12 -> 13 [label="false"];
    13 -> 4 [label="Fim do loop Outer"];
    13 -> 14;
    14 -> 15 [label="Outer++];
    15 -> 16 [label="Outer < MAXSIZE"];
    16 -> 17;
}
```

<codigos - Sum>
Node 1:
void Sum(matrix Array) {
    register int Outer, Inner;

    int Ptotal = 0;
    int Ntotal = 0;
    int Pcnt = 0;
    int Ncnt = 0;
---
Node 2:
for (Outer = 0; Outer < MAXSIZE; Outer++) 
---
Node 3:
for (Inner = 0; Inner < MAXSIZE; Inner++)
---
Node 4:
if (Array[Outer][Inner] >= 0) {
---
Node 5:
Ptotal += Array[Outer][Inner];
Pcnt++;
}
else {
---
Node 6:
Ntotal += Array[Outer][Inner];
Ncnt++;
}
...
</codigos>
---

---
[analise infeasible_paths Sum]

# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.
---

---
[cdfg RandomInteger]

To model the function `update_seed` using Control Flow Dataflow Graph (CDFG), we break down each operation into nodes connected sequentially without branches.

1. **Nodes:**
   - Node 1: Use of Seed for multiplication.
   - Node 2: Multiply by 133.
   - Node 3: Add 81 to the result.
   - Node 4: Compute modulo 8095 and assign back to Seed.
   - Node 5: Return the updated Seed.

2. **Edges:**
   - Each node is connected in a straight line (Node 1 → Node 2 → Node 3 → Node 4 → Node 5).

This graph captures each step's dependencies and transformations, showing how the value of Seed evolves through arithmetic operations before being returned.

```code
/* C code for update_seed function */
void update_seed() {
    int temp = seed * 133;
    temp += 81;
    seed = temp % 8095;
}

/* Corresponding CDFG nodes and edges */
Node 1: Use of Seed (C-Use)
Edge → Node 2

Node 2: Multiply by 133 (C-Use from Node 1)
Edge → Node 3

Node 3: Add 81 (C-Use from Node 2)
Edge → Node 4

Node 4: Modulo 8095 and assign to Seed (Defining Seed)
Edge → Node 5

Node 5: Return statement (C-Use of updated Seed)
```
---

---
[analise infeasible_paths RandomInteger]

```markdown
Nenhum caminho inviável foi identificado.
```
---

---
**Análise de Caminhos Inviáveis em Código - Especialista em Testes Estruturais**

**Instruções de Entrada:**  
Forneça:  
1. O código-fonte a ser analisado  
2. Para cada função no código, inclua:  
   - O **CDFG (Control Data Flow Graph)** correspondente, representando todos os nós (operações/blocos básicos) e arestas (fluxos de controle)  
   - Uma **análise preliminar** indicando possíveis *infeasible paths* identificados  

---

**Processo de Análise (Executado Automaticamente):**  

**1. Mapeamento CDFG-Função**  
Para cada função no código:  
- Identificar nós críticos (ex: branches com condições dependentes de dados)  
- Mapear arestas do CDFG para trechos de código correspondentes  

**2. Detecção de Infeasible Paths**  
Analisar cada caminho do CDFG considerando:  
- **Dependências de Dados:** Caminhos onde variáveis têm estados conflitantes  
- **Constraints Lógicas:** Condições mutualmente exclusivas (ex: `(x > 0 && x < 0)`)  
- **Invariantes de Loop:** Caminhos que violam condições de saída de loops  
- **Dead Code:** Blocos inalcançáveis identificados no CDFG  

**3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**4. Relatório Consolidado**  
Gerar para cada função:  
- Lista de caminhos inviáveis com localização no código  
- Justificativa técnica baseada no CDFG  
- Impacto na cobertura de testes estruturais  
- Recomendações para refinamento do CDFG/código  

---

**Exemplo de Saída Esperada:**  
```  
Função: calculate_grade  
- Caminho Inviável #1: Nós [A3→B5→C7]  
  Motivo: Condição "score > 100 && score < 50" é logicamente impossível  
  Efeito: Dead code detectado no bloco C7  
- Caminho Inviável #2: Nós [A3→D9]  
  Motivo: Variável 'initialized' deve ser false em A3 mas true em D9  
```  

**Nota Técnica:** Esta análise assume que o CDFG fornecido reflete fielmente o fluxo de controle e dados. Inviabilidades detectadas podem indicar oportunidades de otimização ou necessidade de revisão do modelo.
---
