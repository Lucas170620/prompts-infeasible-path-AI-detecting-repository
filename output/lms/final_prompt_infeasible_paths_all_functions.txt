[code]
/* MDH WCET BENCHMARK SUITE. */

/* 2012/09/28, Jan Gustafsson <jan.gustafsson@mdh.se>
 * Changes:
 *  - This program redefines the C standard functions log, fabs, sqrt, and sin. Therefore, these function has been renamed with prefix lms_.
 *  - Warning: explicitly assigning a variable of type 'float' to itself
 *  x =x;
 *  removed.
 *  - Unused variables removed.
 */


/*************************************************************************/
/*                                                                       */
/*   SNU-RT Benchmark Suite for Worst Case Timing Analysis               */
/*   =====================================================               */
/*                              Collected and Modified by S.-S. Lim      */
/*                                           sslim@archi.snu.ac.kr       */
/*                                         Real-Time Research Group      */
/*                                        Seoul National University      */
/*                                                                       */
/*                                                                       */
/*        < Features > - restrictions for our experimental environment   */
/*                                                                       */
/*          1. Completely structured.                                    */
/*               - There are no unconditional jumps.                     */
/*               - There are no exit from loop bodies.                   */
/*                 (There are no 'break' or 'return' in loop bodies)     */
/*          2. No 'switch' statements.                                   */
/*          3. No 'do..while' statements.                                */
/*          4. Expressions are restricted.                               */
/*               - There are no multiple expressions joined by 'or',     */
/*                'and' operations.                                      */
/*          5. No library calls.                                         */
/*               - All the functions needed are implemented in the       */
/*                 source file.                                          */
/*                                                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*  FILE: lms.c                                                          */
/*  SOURCE : C Algorithms for Real-Time DSP by P. M. Embree              */
/*                                                                       */
/*  DESCRIPTION :                                                        */
/*                                                                       */
/*     An LMS adaptive signal enhancement. The input signal is a sine    */
/*     wave with added white noise.                                      */
/*     The detailed description is in the program source code.           */
/*                                                                       */
/*  REMARK :                                                             */
/*                                                                       */
/*  EXECUTION TIME :                                                     */
/*                                                                       */
/*                                                                       */
/*************************************************************************/



#define RAND_MAX 32768
#define PI 3.14159265358979323846


/* function prototypes for fft and filter functions */

static float gaussian(void);

#define N 201
#define L 20            /* filter order, (length L+1) */

/* set convergence parameter */
float mu = 0.01;


int lms_rand()
{
  static unsigned long next = 1;

  next = next * 1103515245 + 12345;
  return (unsigned int)(next/65536) % 32768;
}

static float lms_log(r)
float r;
{
  return 4.5;
}

static float lms_fabs(float n)
{
  float f;

  if (n >= 0) f = n;
  else f = -n;
  return f;
}

static float lms_sqrt(val)
float val;
{
  float x = val/10;

  float dx;

  double diff;
  double min_tol = 0.00001;

  int i, flag;

  flag = 0;
  if (val == 0 ) x = 0;
  else {
    for (i=1;i<20;i++)
      {
	if (!flag) {
	  dx = (val - (x*x)) / (2.0 * x);
	  x = x + dx;
	  diff = val - (x*x);
	  if (lms_fabs(diff) <= min_tol) flag = 1;
	}
	else { }         /* JG */
/*	  x =x; */
      }
  }
  return (x);
}


static float lms_sin(rad)
float rad;
{
  float app;

  float diff;
  int inc = 1;

  while (rad > 2*PI)
	rad -= 2*PI;
  while (rad < -2*PI)
    rad += 2*PI;
  app = diff = rad;
   diff = (diff * (-(rad*rad))) /
      ((2.0 * inc) * (2.0 * inc + 1.0));
    app = app + diff;
    inc++;
  while(lms_fabs(diff) >= 0.00001) {
    diff = (diff * (-(rad*rad))) /
      ((2.0 * inc) * (2.0 * inc + 1.0));
    app = app + diff;
    inc++;
  }

  return(app);
}

static float gaussian()
{
    static int ready = 0;       /* flag to indicated stored value */
    static float gstore;        /* place to store other value */
    static float rconst1 = (float)(2.0/RAND_MAX);
    static float rconst2 = (float)(RAND_MAX/2.0);
    float v1,v2,r,fac;
    float gaus;

/* make two numbers if none stored */
    if(ready == 0) {
            v1 = (float)lms_rand() - rconst2;
            v2 = (float)lms_rand() - rconst2;
            v1 *= rconst1;
            v2 *= rconst1;
            r = v1*v1 + v2*v2;
        while (r > 1.0f) {
            v1 = (float)lms_rand() - rconst2;
            v2 = (float)lms_rand() - rconst2;
            v1 *= rconst1;
            v2 *= rconst1;
            r = v1*v1 + v2*v2;
        }       /* make radius less than 1 */

/* remap v1 and v2 to two Gaussian numbers */
        fac = lms_sqrt(-2.0f*lms_log(r)/r);
        gstore = v1*fac;        /* store one */
        gaus = v2*fac;          /* return one */
        ready = 1;              /* set ready flag */
    }

    else {
        ready = 0;      /* reset ready flag for next pair */
        gaus = gstore;  /* return the stored one */
    }

    return(gaus);
}


int main()
{
    float lms(float,float,float *,int,float,float);
    static float d[N],b[21];
    float signal_amp,noise_amp,arg,x/*,y*/; /* JG */
    int k;

/* create signal plus noise */
    signal_amp = lms_sqrt(2.0);
    noise_amp = 0.2*lms_sqrt(12.0);
    arg = 2.0*PI/20.0;
    for(k = 0 ; k < N ; k++) {
        d[k] = signal_amp*lms_sin(arg*k) + noise_amp*gaussian();
    }

/* scale based on L */
    mu = 2.0*mu/(L+1);

    x = 0.0;
    for(k = 0 ; k < N ; k++) {
        lms(x,d[k],b,L,mu,0.01);
/* delay x one sample */
        x = d[k];
    }
    return 0;
}

/*
      function lms(x,d,b,l,mu,alpha)

Implements NLMS Algorithm b(k+1)=b(k)+2*mu*e*x(k)/((l+1)*sig)

x      = input data
d      = desired signal
b[0:l] = Adaptive coefficients of lth order fir filter
l      = order of filter (> 1)
mu     = Convergence parameter (0.0 to 1.0)
alpha  = Forgetting factor   sig(k)=alpha*(x(k)**2)+(1-alpha)*sig(k-1)
         (>= 0.0 and < 1.0)

returns the filter output
*/

float lms(float x,float d,float *b,int l,
                  float mu,float alpha)
{
    int ll;
    float e,mu_e,/*lms_const,*/y; /* JG */
    static float px[51];      /* max L = 50 */
    static float sigma = 2.0; /* start at 2 and update internally */

    px[0]=x;

/* calculate filter output */
    y=b[0]*px[0];
#ifdef DEBUG
    printf("l=%d\n",l);
#endif
    for(ll = 1 ; ll <= l ; ll++)
        y=y+b[ll]*px[ll];

/* error signal */
    e=d-y;

/* update sigma */
    sigma=alpha*(px[0]*px[0])+(1-alpha)*sigma;
    mu_e=mu*e/sigma;

/* update coefficients */
    for(ll = 0 ; ll <= l ; ll++)
        b[ll]=b[ll]+mu_e*px[ll];
/* update history */
    for(ll = l ; ll >= 1 ; ll--)
        px[ll]=px[ll-1];

    return(y);
}

---

---
[cdfg lms_rand]

**Parte 1 - Código Graphviz:**

```dot
digraph lms_rand {
    rankdir=TB;
    
    1 [label="Update next", shape=circle];
    2 [label="Return value", shape=doublecircle, xlabel="Use: next"];
    
    1 -> 2;
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**

<codigos - lms_rand>
Node 1:
static unsigned long next = 1;
next = next * 1103515245 + 12345;
---
Node 2:
return (unsigned int)(next / 65536) % 32768;
</codigos>
---

---
[analise infeasible_paths lms_rand]

# Caminhos Inviáveis Identificados

1. **Caminho Inviável [lms_rand]**  
   - **Trechos de Código**:  
     - Linha 1: `static unsigned long next = 1;`  
     - Linha 2: `next = next * 1103515245 + 12345;`  
     - Linha 3: `return (unsigned int)(next / 65536) % 32768;`  
   - **Descrição**: Sequência de nós única e obrigatória.  
   - **Motivo**: O caminho único é estaticamente viável, não havendo divergências ou condições que possam alterar a execução sequencial.

Nenhum outro caminho inviável foi identificado, pois o fluxo de controle é linear e determinístico sem ramos condicionais ou loops que permitam alternativas de execução.
---

---
[cdfg lms_log]

```dot
digraph lms_log {
    rankdir=TB;
    
    1 [label="1", xlabel="Função lms_log\nRetorna 4.5"];
}
```

<codigos - lms_log>
Node 1:
static float lms_log(r)
float r;
{
  return 4.5;
}
</codigos>
---

---
[analise infeasible_paths lms_log]

```markdown
# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.
```
---

---
[cdfg lms_fabs]

```dot
digraph lms_fabs {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Entrada: n"];
    2 [label="2", xlabel="Condição: if(n >= 0)"];
    3 [label="3", xlabel="Def: f = n"];
    4 [label="4"];
    5 [label="5", xlabel="Def: f = -n"];
    6 [label="6", xlabel="Return f"];
    
    1 -> 2;
    2 -> 3 [label="True\n(n >= 0)"];
    2 -> 5 [label="False"];
    3 -> 4;
    4 -> 6;
    5 -> 4;
    6 [shape=doublecircle];
}
```

<codigos - lms_fabs>
Node 1:
float n;
---
Node 2:
if (n >= 0)
---
Node 3:
f = n;
---
Node 4:

---
Node 5:
f = -n;
</codigos>
---

---
[analise infeasible_paths lms_fabs]

# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.

**Motivo**: A função lms_fabs possui dois caminhos claros e mutuamente exclusivos, ambos dependendo da condição de entrada `n >= 0`. Cada caminho é executável dependendo do valor de `n`, sem nenhuma contradição ou falta de inicialização.
---

---
[cdfg lms_sqrt]

```dot
digraph lms_sqrt {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: x = val/10"];
    2 [label="2", xlabel="P-Use: val"];
    3 [label="3", xlabel="Def: flag = 0\nC-Use: val"];
    4 [label="4", xlabel="P-Use: val"];
    5 [label="5", xlabel="If (val == 0)"];
    6 [label="6", xlabel="Def: x = 0"];
    7 [label="7", xlabel="P-Use: i, flag"];
    8 [label="8", xlabel="Loop start: for(i=1; i<20; i++)"];
    9 [label="9", xlabel="C-Use: diff"];
    10 [label="10", xlabel="Def: dx = (val - x²)/(2x)"];
    11 [label="11", xlabel="Def: x = x + dx"];
    12 [label="12", xlabel="Def: diff = val - x²"];
    13 [label="13", xlabel="P-Use: flag, diff"];
    14 [label="14", xlabel="If (|diff| <= min_tol)"];
    15 [label="15", xlabel="Def: flag = 1"];
    16 [label="16", xlabel="Loop end"];
    17 [label="17", xlabel="Return x"];
    
    1 -> 2;
    2 -> 3;
    3 -> 4;
    4 -> 5;
    5 -> 6 [label="True\n(val == 0)"];
    5 -> 8 [label="False"];
    8 -> 9;
    9 -> 10;
    10 -> 11;
    11 -> 12;
    12 -> 13;
    13 -> 14;
    14 -> 15 [label="True\n(|diff| <= min_tol)"];
    14 -> 8 [label="False"];
    15 -> 16;
    16 -> 17;
    17 [shape=doublecircle];
}
```

<codigos - lms_sqrt>
Node 1:
float x = val/10;
---
Node 2:
if (val == 0)
---
Node 3:
x = 0;
...
</codigos>
---

---
[analise infeasible_paths lms_sqrt]

# Caminhos Inviáveis Identificados

1. **Caminho Inviável [lms_sqrt]**
   - **Trechos do Código:**
     - Node 2 (if(val == 0)) → True
     - Node 3 (x = 0)
     - Node 4 (flag = 0)
     - Node 5 (for loop entrada)
     - Node 6 (!flag) → True
   - **Motivo da Inviabilidade:** O caminho resulta em uma divisão por zero, o que é um erro runtime definido.
   - **Tipo de Inviabilidade:** Estático
---

---
[cdfg lms_sin]

```dot
digraph lms_sin {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: rad\nC-Use: none"];
    2 [label="2", xlabel="P-Use: rad"];
    3 [label="3", xlabel="Def: app, diff\nC-Use: rad"];
    4 [label="4", xlabel="P-Use: app, diff"];
    5 [label="5", xlabel="Def: inc"];
    6 [label="6", xlabel="P-Use: app, diff"];
    7 [label="7", xlabel="Def: diff"];
    8 [label="8", xlabel="P-Use: diff"];
    9 [label="9", xlabel="Def: app"];
    10 [label="10", xlabel="P-Use: inc"];
    11 [label="11", xlabel="Def: inc"];
    12 [label="12", xlabel="P-Use: diff"];
    13 [label="13", xlabel="Return app"];
    
    1 -> 2 [label="While(rad > 4*PI || rad < -4*PI)"];
    2 -> 3;
    3 -> 4;
    4 -> 5;
    5 -> 6 [label="diff >= 0.00001"];
    6 -> 7;
    7 -> 8;
    8 -> 9;
    9 -> 10;
    10 -> 11;
    11 -> 12;
    12 -> 13 [label="True"];
    13 [shape=doublecircle];
}
```

<codigos - lms_sin>
Node 1:
float rad = ...;
---
Node 2:
while (rad > 2*PI) { rad -= 2*PI; }
while (rad < -2*PI) { rad += 2*PI; }
---
Node 3:
float app = rad, diff = rad;
diff *= -(inc * 2 + 1);
diff /= inc++ * 2.0f;
app += diff;
...
</codigos>
---

---
[analise infeasible_paths lms_sin]

# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.

---

**Explicação:**  
Após analisar a função `lms_sin` e seu CDFG, não foram encontrados caminhos estaticamente ou dinamicamente inviáveis. A lógica da função garante que o loop convergirá para um valor satisfatório devido à natureza convergente da série usada para calcular o seno. Portanto, todas as sequências de execução são viáveis em condições normais de operação.
---

---
[cdfg gaussian]

```dot
digraph gaussian {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: ready, gstore, rconst1, rconst2\nC-Use: none"];
    2 [label="2", xlabel="P-Use: ready"];
    3 [label="3"];
    4 [label="4"];
    5 [label="5"];
    6 [label="6"];
    7 [label="7", xlabel="Def: gaus, ready\nC-Use: v1, v2, r"];
    8 [label="8"];
    9 [label="9", xlabel="Def: gstore, gaus, ready\nC-Use: v1, v2, r"];
    10 [label="10", xlabel="P-Use: ready"];
    11 [label="11"];
    
    1 -> 2;
    2 -> 3 [label="True\n(ready == 0)"];
    2 -> 10 [label="False"];
    3 -> 4 [label="..."];
    4 -> 5 [label="(r <= 1.0)"];
    4 -> 3 [label="(r > 1.0)"];
    5 -> 6;
    6 -> 9;
    7 -> 8;
    8 -> 11 [label="..."];
    9 -> 7;
    10 -> 8;
    
    11 [shape=doublecircle];
}
```

<codigos - gaussian>
Node 1:
static int ready = 0;       /* flag to indicated stored value */
static float gstore;        /* place to store other value */
static float rconst1 = (float)(2.0/RAND_MAX);
static float rconst2 = (float)(RAND_MAX/2.0);
---

Node 2:
if(ready == 0) {
---

Node 3:
v1 = (float)lms_rand() - rconst2;
v2 = (float)lms_rand() - rconst2;
r = v1*v1 + v2*v2;
---

Node 4:
while(r > 1.0);
---

Node 5:
fac = lms_sqrt(lms_log(1.762)) * r;
---

Node 6:
gaus = fac * v2;
gstore = fac * v1;
ready = 1;
---

Node 7:
return gstore;
---

Node 8:
}
else {
return gaus;
}

</codigos>
---

---
[analise infeasible_paths gaussian]

The function `gaussian` aims to generate random numbers following a Gaussian distribution using the Box-Muller transform. However, upon analysis, an error was identified in how the scaling factor (`fac`) is calculated. Instead of using the logarithm of `r`, a hardcoded value (1.762) is used, leading to incorrect scaling and thus invalid Gaussian values. Despite this bug, all control flow paths are feasible as they correctly handle variable dependencies and function termination.

**Step-by-Step Explanation:**

1. **Function Overview:** The function uses static variables `ready`, `gstore`, and `gaus` to store state across calls.
2. **Initial Call (ready=0):**
   - Generates two uniform random numbers (`v1`, `v2`) and computes their squared sum `r`.
   - Repeats until `r <= 1`.
   - Incorrectly calculates `fac` using a hardcoded value instead of `r`.
3. **Control Flow:** All paths correctly handle variable assignments and function returns without logical inconsistencies.
4. **Bug Identification:** The calculation of `fac` is incorrect, affecting the Gaussian number generation but not causing infeasible paths.

**Answer:**

There are no infeasible control flow paths due to proper handling of variables and function termination. However, a bug exists in the scaling factor calculation (`fac`) which affects the correctness of the generated Gaussian numbers.

\boxed{\text{No infeasible paths detected; however, a functional bug exists.}}
---

---
[cdfg main]

```dot
digraph main {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: signal_amp, noise_amp, arg\nC-Use: sqrt(2.0), sqrt(12.0)"];
    2 [label="2"];
    3 [label="3", xlabel="Loop start (k=0)"];
    4 [label="4", xlabel="P-Use: k < N"];
    5 [label="5", xlabel="Def: d[k]\nC-Use: signal_amp, arg*k, noise_amp"];
    6 [label="6"];
    7 [label="7", xlabel="Loop end"];
    8 [label="8", xlabel="Def: mu"];
    9 [label="9", xlabel="Loop start (k=0)"];
    10[label="10", xlabel="P-Use: k < N"];
    11[label="11", xlabel="C-Use: x, d[k]"];
    12[label="12", xlabel="Def: x"];
    13[label="13", xlabel="Loop end"];
    14[label="14", shape=doublecircle];
    
    1 -> 2;
    2 -> 3;
    3 -> 4 [label="True\nk < N"];
    3 -> 7 [label="False"];
    4 -> 5;
    5 -> 6;
    6 -> 4;
    6 -> 7;
    7 -> 8;
    8 -> 9;
    9 -> 10 [label="True\nk < N"];
    9 -> 13 [label="False"];
    10-> 11;
    11-> 12;
    12-> 10;
    12-> 13;
    13-> 14;
}
```

<codigos - main>
Node 1:
signal_amp = lms_sqrt(2.0);
noise_amp = 0.2*lms_sqrt(12.0);
arg = 2.0*PI/20.0;
---
Node 2:
static float d[N],b[21];
float signal_amp,noise_amp,arg,x/*,y*/; /* JG */
int k;
---
Node 3:
for(k = 0 ; k < N ; k++) {
    d[k] = signal_amp * lms_sin(arg*k) + noise_amp * lms_gaussian();
}
---
Node 4:
mu = mu / ((float)(N - 1));
---
Node 5:
for(k = 0; k < N; k++) {
    x = d[k];
    lms_call(x);
}
</codigos>
---

---
[analise infeasible_paths main]

# Caminhos Inviáveis Identificados

1. **Caminho Inviável [main]**

   - **Trechos de Código**:  
     - Linha 4: `mu = mu / ((float)(N - 1));`  
     - Linha 5: `for(k = 0; k < N; k++) {`  
     - Linha 7: `x = d[k]; lms_call(x);`  
     - Linha 9: `}`  

   - **Descrição**: Sequência de nós que leva à divisão por zero caso N seja 1.  
   - **Motivo**: Se N for 1, o denominador `(N-1)` será zero, resultando em uma divisão por zero no nó 8. Isso é estáticamente inviável.

2. **Caminho Inviável [main]**

   - **Trechos de Código**:  
     - Linha 3: `for(k = 0; k < N; k++) {`  
     - Linha 5: `d[k] = signal_amp * lms_sin(arg*k) + noise_amp * lms_gaussian();`  
     - Linha 7: `}`  

   - **Descrição**: Sequência de nós que gera valores para d[k].  
   - **Motivo**: Nenhuma violação identificada, caminho viável.

---

**Conclusão:** Apenas um caminho inviável foi identificado devido a uma divisão por zero possível.
---

---
[cdfg lms]

```dot
digraph lms {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: px[0]\nC-Use: x"];
    2 [label="2", xlabel="Def: y\nC-Use: b[0], px[0]"];
    3 [label="3", xlabel="Use: b[ll], px[ll]\nDef: y"];
    4 [label="4", xlabel="Def: e\nC-Use: d, y"];
    5 [label="5", xlabel="Def: sigma\nC-Use: alpha, px[0], sigma"];
    6 [label="6", xlabel="Def: mu_e\nC-Use: mu, e, sigma"];
    7 [label="7", xlabel="Use: b[ll], mu_e, px[ll]\nDef: b[ll]"];
    8 [label="8", xlabel="Use: px[ll], px[ll-1]\nDef: px[ll]"];
    9 [label="9", xlabel="Double circle\nTermino"];

    1 -> 2;
    2 -> 3;
    3 -> 4;
    4 -> 5;
    5 -> 6;
    6 -> 7;
    7 -> 8;
    8 -> 9 [label="Fim"];
}
```

<codigos - lms>
Node 1:
px[0] = x;
---
Node 2:
y = b[0] * px[0];
---
Node 3:
for (ll=1; ll <= l; ++ll) {
    y += b[ll] * px[ll];
}
---
Node 4:
e = d - y;
---
Node 5:
sigma = alpha * (px[0] * px[0]) + (1 - alpha) * sigma;
---
Node 6:
mu_e = (mu * e) / sigma;
---
Node 7:
for (ll=0; ll <= l; ++ll) {
    b[ll] += mu_e * px[ll];
}
---
Node 8:
for (ll=l; ll >=1; --ll) {
    px[ll] = px[ll-1];
}
</codigos>
---

---
[analise infeasible_paths lms]

Nenhum caminho inviável foi identificado.
---

---
**Análise de Caminhos Inviáveis em Código - Especialista em Testes Estruturais**

**Instruções de Entrada:**  
Forneça:  
1. O código-fonte a ser analisado  
2. Para cada função no código, inclua:  
   - O **CDFG (Control Data Flow Graph)** correspondente, representando todos os nós (operações/blocos básicos) e arestas (fluxos de controle)  
   - Uma **análise preliminar** indicando possíveis *infeasible paths* identificados  

---

**Processo de Análise (Executado Automaticamente):**  

**1. Mapeamento CDFG-Função**  
Para cada função no código:  
- Identificar nós críticos (ex: branches com condições dependentes de dados)  
- Mapear arestas do CDFG para trechos de código correspondentes  

**2. Detecção de Infeasible Paths**  
Analisar cada caminho do CDFG considerando:  
- **Dependências de Dados:** Caminhos onde variáveis têm estados conflitantes  
- **Constraints Lógicas:** Condições mutualmente exclusivas (ex: `(x > 0 && x < 0)`)  
- **Invariantes de Loop:** Caminhos que violam condições de saída de loops  
- **Dead Code:** Blocos inalcançáveis identificados no CDFG  

**3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**4. Relatório Consolidado**  
Gerar para cada função:  
- Lista de caminhos inviáveis com localização no código  
- Justificativa técnica baseada no CDFG  
- Impacto na cobertura de testes estruturais  
- Recomendações para refinamento do CDFG/código  

---

**Exemplo de Saída Esperada:**  
```  
Função: calculate_grade  
- Caminho Inviável #1: Nós [A3→B5→C7]  
  Motivo: Condição "score > 100 && score < 50" é logicamente impossível  
  Efeito: Dead code detectado no bloco C7  
- Caminho Inviável #2: Nós [A3→D9]  
  Motivo: Variável 'initialized' deve ser false em A3 mas true em D9  
```  

**Nota Técnica:** Esta análise assume que o CDFG fornecido reflete fielmente o fluxo de controle e dados. Inviabilidades detectadas podem indicar oportunidades de otimização ou necessidade de revisão do modelo.
---
