[code]
/* $Id: expint.c,v 1.2 2005/04/04 11:34:58 csg Exp $ */



/************************************************************************

 * FROM:

 *   http://sron9907.sron.nl/manual/numrecip/c/expint.c

 *

 * FEATURE:

 *   One loop depends on a loop-invariant value to determine

 *   if it run or not.

 *

 ***********************************************************************/





long int expint(int n, long int x);



void main(void)

{

  expint(50,1);

  // with  expint(50,21) as argument, runs the short path

  // in expint.   expint(50,1)  gives the longest execution time

}



long int foo(long int x)

{

  return x*x+(8*x)<<4-x;

}





/* Function with same flow, different data types,

   nonsensical calculations */

long int expint(int n, long int x)

{

  int      i,ii,nm1;

  long int a,b,c,d,del,fact,h,psi,ans;



  nm1=n-1;                      /* arg=50 --> 49 */



  if(x>1)                       /* take this leg? */

    {

      b=x+n;

      c=2e6;

      d=3e7;

      h=d;



      for (i=1;i<=100;i++)      /* MAXIT is 100 */

        {

          a = -i*(nm1+i);

          b += 2;

          d=10*(a*d+b);

          c=b+a/c;

          del=c*d;

          h *= del;

          if (del < 10000)

            {

              ans=h*-x;

              return ans;

            }

        }

    }

  else                          /* or this leg? */

    {

      // For the current argument, will always take

      // '2' path here:

      ans = nm1 != 0 ? 2 : 1000;

      fact=1;

      for (i=1;i<=100;i++)      /* MAXIT */

        {

          fact *= -x/i;

          if (i != nm1)         /* depends on parameter n */

            del = -fact/(i-nm1);

          else                  /* this fat piece only runs ONCE */

            {                   /* runs on iter 49 */

              psi = 0x00FF;

              for (ii=1;ii<=nm1;ii++) /*  */

                psi += ii + nm1;

              del=psi+fact*foo(x);

            }

          ans += del;

          /* conditional leave removed */

        }



    }

  return ans;

}











/*  #define MAXIT 100 */

/*  #define EULER 0.5772156649 */

/*  #define FPMIN 1.0e-30 */

/*  #define EPS 1.0e-7 */

/*  float expint(int n, float x) */

/*  { */

/*    void nrerror(char error_text[]); */

/*    int i,ii,nm1; */

/*    float a,b,c,d,del,fact,h,psi,ans; */



/*    nm1=n-1; */

/*    if (n < 0 || x < 0.0 || (x==0.0 && (n==0 || n==1))) */

/*    nrerror("bad arguments in expint");                */

/*     else {  */

/*    if (n == 0)  */

/*      ans=exp(-x)/x; */

/*    else  */

/*      { */

/*        if (x == 0.0)  */

/*          ans=1.0/nm1; */

/*        else  */

/*          { */

/*            if (x > 1.0) { */

/*              b=x+n; */

/*              c=1.0/FPMIN; */

/*              d=1.0/b; */

/*              h=d; */



/*              for (i=1;i<=MAXIT;i++)  */

/*              { */

/*                a = -i*(nm1+i); */

/*                b += 2.0; */

/*                d=1.0/(a*d+b); */

/*                c=b+a/c; */

/*                del=c*d; */

/*                h *= del; */

/*                if (fabs(del-1.0) < EPS)  */

/*                  { */

/*                    ans=h*exp(-x); */

/*                    return ans; */

/*                  } */

/*              } */



/*            nrerror("continued fraction failed in expint");*/

/*          }  */

/*          else  */

/*            { */

/*              ans = (nm1!=0 ? 1.0/nm1 : -log(x)-EULER); */

/*            fact=1.0; */

/*            for (i=1;i<=MAXIT;i++) { */

/*              fact *= -x/i; */

/*              if (i != nm1) del = -fact/(i-nm1); */

/*              else { */

/*                psi = -EULER; */

/*                for (ii=1;ii<=nm1;ii++) psi += 1.0/ii; */

/*                del=fact*(-log(x)+psi); */

/*              } */

/*              ans += del; */

/*              if (fabs(del) < fabs(ans)*EPS) return ans; */

/*            } */

/*            nrerror("series failed in expint"); */

/*          } */

/*        } */

/*      } */

/*    } */

/*    return ans; */

/*  } */

---

---
[cdfg expint]

```dot
digraph expint {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: nm1\nC-Use: n"];
    2 [label="2", xlabel="P-Use: x"];
    3 [label="3", xlabel="If taken (x>1): Def b, c, d, h\nElse: Def ans"];
    4 [label="4", xlabel="Def a"];
    5 [label="5", xlabel="Def b"];
    6 [label="6", xlabel="Def d"];
    7 [label="7", xlabel="Def c"];
    8 [label="8", xlabel="Def del"];
    9 [label="9", xlabel="Def h"];
    10 [label="10", xlabel="P-Use: del"];
    11 [label="11", xlabel="Def ans"];
    12 [label="12", xlabel="Return ans"];
    13 [label="13", xlabel="Else case (x<=1): Def ans"];
    14 [label="14", xlabel="Def fact"];
    15 [label="15", xlabel="P-Use: i, del"];
    16 [label="16", xlabel="Def psi"];
    17 [label="17", xlabel="Inner loop def: ii"];
    18 [label="18", xlabel="Def del"];
    19 [label="19", xlabel="Add del to ans"];

    1 -> 2;
    2 -> 3 [label="True\n(x>1)"];
    2 -> 13 [label="False\n(x<=1)"];
    
    // If block (x>1)
    3 -> 4;
    4 -> 5;
    5 -> 6;
    6 -> 7;
    7 -> 8;
    8 -> 9;
    9 -> 10 [label="del < 10000"];
    10 -> 11;
    11 -> 12;
    
    // Else block (x<=1)
    3 -> 14;
    14 -> 15 [label="Loop start"];
    15 -> 16;
    16 -> 17 [label="i != nm1"];
    17 -> 18;
    18 -> 19;
    19 -> 12;

    12 [shape=doublecircle];
}
```

```codigos - expint
Node 1:
nm1 = n-1;
---
Node 2:
if (x > 1)
---
Node 3:
b=x+n; c=2e6; d=3e7; h=d;
---
Node 4:
a = -i*(nm1+i);
---
Node 5:
b += 2;
---
Node 6:
d=10*(a*d + b);
---
Node 7:
c = b + a/c;
---
Node 8:
del=c*d;
---
Node 9:
h *= del;
---
Node 10:
if (del < 10000)
---
Node 11:
ans = h * -x;
---
Node 12:
return ans;
---
Node 13:
ans = nm1 != 0 ? 2 : 1000;
fact=1;
---
Node 14:
for (i=1; i<=100; i++)
---
Node 15:
fact *= -x/i;
---
Node 16:
if (i != nm1)
---
Node 17:
psi = 0x00FF;
for (ii=1; ii<=nm1; ii++) psi += ii + nm1;
---
Node 18:
del=fact*(-log(x) + psi);
---
Node 19:
ans += del;
--- 
```
---

---
[analise infeasible_paths expint]

The problem involves analyzing a piece of C code and identifying potential infeasible paths based on specific input constraints. After examining the code structure and control flow, we found an infeasible path scenario:

When `n > 101` and `x <= 1`, the loop inside the else block runs from `i = 1` to `100`. Since `n > 101` implies `nm1 = n - 1 > 100`, none of the iterations will reach `i = nm1`. Consequently, the code inside node 17 (the else clause) is never executed, making that path infeasible.

**Step-by-Step Explanation:**

1. **Understand the Control Flow:**
   - The code splits into two main paths based on whether `x > 1` or `x <= 1`.
   - In the `x <= 1` case, a loop runs from `i = 1` to `100`, checking if `i == nm1`.

2. **Analyze Loop Execution:**
   - If `n > 101`, then `nm1 > 100`.
   - Since the loop only goes up to `i = 100`, `i` can never equal `nm1` within this range.

3. **Identify Unreachable Code:**
   - The else clause (node 17) inside the loop is unreachable when `n > 101` because `i` never equals `nm1`.
   - This makes any code relying on node 17 being executed under these conditions an infeasible path.

4. **Conclusion on Infeasibility:**
   - Paths leading to node 17 are dynamically infeasible when `x <= 1` and `n > 101` because the loop cannot reach `i = nm1`.

**Answer:**

The identified infeasible path occurs under the conditions where `n > 101` and `x <= 1`. In such cases, the code within node 17 is unreachable. Therefore, any attempt to execute this part of the code results in an infeasible path.

$\boxed{\text{When } n > 101 \text{ and } x \leq 1, \text{ the path involving node 17 is infeasible.}}$
---

---
[cdfg foo]

To generate a precise Control and Data Flow Graph (CDFG) for the function `foo`, we break down each operation and represent data flow between them. Here's the structured CDFG in both the DOT notation and code mapping.

### CDFG Structure:
- **Nodes**:
  - Node 1: Compute `a = x * x`
  - Node 2: Compute `b = 8 * x`
  - Node 3: Compute `c = b << (4 - x)`
  - Node 4: Compute `result = a + c`

- **Edges**:
  - Node 1 → Node 4 (data flow for `a`)
  - Node 2 → Node 3 (data flow for `b`)
  - Node 3 → Node 4 (data flow for `c`)

### DOT Notation:
```dot
digraph CDFG {
    node1 [label="Compute a = x * x"];
    node2 [label="Compute b = 8 * x"];
    node3 [label="Compute c = b << (4 - x)"];
    node4 [label="Compute result = a + c"];
    
    node1 -> node4;
    node2 -> node3;
    node3 -> node4;
}
```

### Code Mapping:
```codemapping
Node 1: Compute a = x * x
Node 2: Compute b = 8 * x
Node 3: Compute c = b << (4 - x)
Node 4: Compute result = a + c; return result
```

This CDFG precisely captures the data flow and control flow of the `foo` function, showing how each operation contributes to the final result.
---

---
[analise infeasible_paths foo]

# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.
---

---
[cdfg main]

**Parte 1 - Código Graphviz:**

```dot
digraph main {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="expint(50, 1);"];
    2 [label="2", shape=doublecircle, xlabel="Exit"];

    1 -> 2;
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**

<codigos - main>
Node 1:
expint(50,1);
---
</codigos>
---

---
[analise infeasible_paths main]

Nenhum caminho inviável foi identificado.
---

---
**Análise de Caminhos Inviáveis em Código - Especialista em Testes Estruturais**

**Instruções de Entrada:**  
Forneça:  
1. O código-fonte a ser analisado  
2. Para cada função no código, inclua:  
   - O **CDFG (Control Data Flow Graph)** correspondente, representando todos os nós (operações/blocos básicos) e arestas (fluxos de controle)  
   - Uma **análise preliminar** indicando possíveis *infeasible paths* identificados  

---

**Processo de Análise (Executado Automaticamente):**  

**1. Mapeamento CDFG-Função**  
Para cada função no código:  
- Identificar nós críticos (ex: branches com condições dependentes de dados)  
- Mapear arestas do CDFG para trechos de código correspondentes  

**2. Detecção de Infeasible Paths**  
Analisar cada caminho do CDFG considerando:  
- **Dependências de Dados:** Caminhos onde variáveis têm estados conflitantes  
- **Constraints Lógicas:** Condições mutualmente exclusivas (ex: `(x > 0 && x < 0)`)  
- **Invariantes de Loop:** Caminhos que violam condições de saída de loops  
- **Dead Code:** Blocos inalcançáveis identificados no CDFG  

**3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**4. Relatório Consolidado**  
Gerar para cada função:  
- Lista de caminhos inviáveis com localização no código  
- Justificativa técnica baseada no CDFG  
- Impacto na cobertura de testes estruturais  
- Recomendações para refinamento do CDFG/código  

---

**Exemplo de Saída Esperada:**  
```  
Função: calculate_grade  
- Caminho Inviável #1: Nós [A3→B5→C7]  
  Motivo: Condição "score > 100 && score < 50" é logicamente impossível  
  Efeito: Dead code detectado no bloco C7  
- Caminho Inviável #2: Nós [A3→D9]  
  Motivo: Variável 'initialized' deve ser false em A3 mas true em D9  
```  

**Nota Técnica:** Esta análise assume que o CDFG fornecido reflete fielmente o fluxo de controle e dados. Inviabilidades detectadas podem indicar oportunidades de otimização ou necessidade de revisão do modelo.
---
