[code]
/* $Id: expint.c,v 1.2 2005/04/04 11:34:58 csg Exp $ */



/************************************************************************

 * FROM:

 *   http://sron9907.sron.nl/manual/numrecip/c/expint.c

 *

 * FEATURE:

 *   One loop depends on a loop-invariant value to determine

 *   if it run or not.

 *

 ***********************************************************************/





long int expint(int n, long int x);



void main(void)

{

  expint(50,1);

  // with  expint(50,21) as argument, runs the short path

  // in expint.   expint(50,1)  gives the longest execution time

}



long int foo(long int x)

{

  return x*x+(8*x)<<4-x;

}





/* Function with same flow, different data types,

   nonsensical calculations */

long int expint(int n, long int x)

{

  int      i,ii,nm1;

  long int a,b,c,d,del,fact,h,psi,ans;



  nm1=n-1;                      /* arg=50 --> 49 */



  if(x>1)                       /* take this leg? */

    {

      b=x+n;

      c=2e6;

      d=3e7;

      h=d;



      for (i=1;i<=100;i++)      /* MAXIT is 100 */

        {

          a = -i*(nm1+i);

          b += 2;

          d=10*(a*d+b);

          c=b+a/c;

          del=c*d;

          h *= del;

          if (del < 10000)

            {

              ans=h*-x;

              return ans;

            }

        }

    }

  else                          /* or this leg? */

    {

      // For the current argument, will always take

      // '2' path here:

      ans = nm1 != 0 ? 2 : 1000;

      fact=1;

      for (i=1;i<=100;i++)      /* MAXIT */

        {

          fact *= -x/i;

          if (i != nm1)         /* depends on parameter n */

            del = -fact/(i-nm1);

          else                  /* this fat piece only runs ONCE */

            {                   /* runs on iter 49 */

              psi = 0x00FF;

              for (ii=1;ii<=nm1;ii++) /*  */

                psi += ii + nm1;

              del=psi+fact*foo(x);

            }

          ans += del;

          /* conditional leave removed */

        }



    }

  return ans;

}











/*  #define MAXIT 100 */

/*  #define EULER 0.5772156649 */

/*  #define FPMIN 1.0e-30 */

/*  #define EPS 1.0e-7 */

/*  float expint(int n, float x) */

/*  { */

/*    void nrerror(char error_text[]); */

/*    int i,ii,nm1; */

/*    float a,b,c,d,del,fact,h,psi,ans; */



/*    nm1=n-1; */

/*    if (n < 0 || x < 0.0 || (x==0.0 && (n==0 || n==1))) */

/*    nrerror("bad arguments in expint");                */

/*     else {  */

/*    if (n == 0)  */

/*      ans=exp(-x)/x; */

/*    else  */

/*      { */

/*        if (x == 0.0)  */

/*          ans=1.0/nm1; */

/*        else  */

/*          { */

/*            if (x > 1.0) { */

/*              b=x+n; */

/*              c=1.0/FPMIN; */

/*              d=1.0/b; */

/*              h=d; */



/*              for (i=1;i<=MAXIT;i++)  */

/*              { */

/*                a = -i*(nm1+i); */

/*                b += 2.0; */

/*                d=1.0/(a*d+b); */

/*                c=b+a/c; */

/*                del=c*d; */

/*                h *= del; */

/*                if (fabs(del-1.0) < EPS)  */

/*                  { */

/*                    ans=h*exp(-x); */

/*                    return ans; */

/*                  } */

/*              } */



/*            nrerror("continued fraction failed in expint");*/

/*          }  */

/*          else  */

/*            { */

/*              ans = (nm1!=0 ? 1.0/nm1 : -log(x)-EULER); */

/*            fact=1.0; */

/*            for (i=1;i<=MAXIT;i++) { */

/*              fact *= -x/i; */

/*              if (i != nm1) del = -fact/(i-nm1); */

/*              else { */

/*                psi = -EULER; */

/*                for (ii=1;ii<=nm1;ii++) psi += 1.0/ii; */

/*                del=fact*(-log(x)+psi); */

/*              } */

/*              ans += del; */

/*              if (fabs(del) < fabs(ans)*EPS) return ans; */

/*            } */

/*            nrerror("series failed in expint"); */

/*          } */

/*        } */

/*      } */

/*    } */

/*    return ans; */

/*  } */

---
Você é um especialista em análise estática de código e teste estrutural. Sua tarefa é analisar código fornecido e gerar um **CDFG (Control and Data Flow Graph)** preciso em formato Graphviz DOT para uma função main.

### Especificações Técnicas:

**1. Linguagem Graphviz DOT:**
- Use digrafos direcionados: `digraph NomeFuncao { ... }`
- Personalize nós com: `NóID [label="Texto" shape="forma" xlabel="info dados"]`
- Formas principais: box (processamento), diamond (decisão), doublecircle (fim)
- Rotule arestas com condições: `A -> B [label="condição"]`
- Use `rankdir=TB` para layout vertical

**2. Construção do CDFG Híbrido:**
Integre estas informações em cada nó:
- **Fluxo de Controle:** sequência de execução básica
- **Fluxo de Dados:** def (definições) e use (usos) de variáveis
- **Tipos de Uso:** C-Use (computacional) e P-Use (predicativo)

**3. Estrutura de Representação:**
- Nós de processo: operações sequenciais
- Nós de decisão: condições if/while/for
- Arestas verdadeiro/falso para bifurcações
- Loops: nó de condição com retorno ao corpo
- Use circulo para representar os nós
- Um circulo duplo para representar o nó final.

### Processamento Obrigatório:

**Para a função especificada:**
1. Identifique todos os blocos básicos
2. Mapeie definições (def) e usos (c-use/p-use) de variáveis
3. Construa o grafo integrando controle e dados
4. Numere nós sequencialmente
5. Gere lista de correspondência código-nós

### Saída Exigida:

**Parte 1 - Código Graphviz:**
```dot
digraph NomeFuncao {
    // Configurações e nós
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**
<codigos - NomeFuncao>
Node [ID]:
[Trecho código relevante]
---
[Próximo node...]
</codigos>

### Exemplo de Referência:

**Código:**
```java
public class Order {
    public void applyDiscount(Customer customer, Product product) {
        boolean isPremium = customer.isPremiumMember();
        boolean isEligibleForDiscount = product.getPrice() > 100.00;
        boolean isOnClearance = product.isOnClearance();
        
        if (isPremium && isEligibleForDiscount) {
            System.out.println("Desconto Premium aplicado.");
        }

        if (isOnClearance) {
            System.out.println("Item em liquidação.");
            if (isPremium && isEligibleForDiscount) {
                System.out.println("Super Desconto para Premium em Liquidação!");
            }
        }
    }
}
```

**Saída Esperada:**
```dot
digraph order {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: isPremium, isEligibleForDiscount, isOnClearance\nC-Use: customer, product"];
    2 [label="2", xlabel="P-Use: isPremium, isEligibleForDiscount"];
    3 [label="3"];
    4 [label="4", xlabel="P-Use: isOnClearance"];
    5 [label="5"];
    6 [label="6", xlabel="P-Use: isPremium, isEligibleForDiscount"];
    7 [label="7"];    
    8 [label="8"];
    
    1 -> 2 ;
    2 -> 3 [label="True\n(isPremium && isEligibleForDiscount)"];
    2 -> 4 [label="False"];
    3 -> 4 ;
    4 -> 5 [label="True\n(isOnClearance)"];
    4 -> 8 [label="False"];
    5 -> 6 ;
    6 -> 7 [label="True"];
    6 -> 8 [label="False"];
    7 -> 8 ;    
    8 [shape=doublecircle];
}
```

<codigos - exemplo>
Node 1:
int y = x * 2;
---
Node 2:
if (y > 10)
---
Node 3:
System.out.println("Maior")
---
Node 4:
return
</codigos>

**Agora, gere o CDFG completo para o código e função fornecidos. Mantenha precisão técnica e complete ambas as partes da saída.**