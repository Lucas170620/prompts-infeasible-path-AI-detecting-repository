
To model the given code snippet using Control Flow Graph (CFG), we break down each instruction into nodes and establish edges based on control flow. Here's the step-by-step explanation:

1. **Node 1**: Initialize `Fnew` and `Fold`.
   - Def: `Fnew=1`, `Fold=0`
   - Use: None

2. **Node 2**: Check condition `i <=30 && i <=n`.
   - Use: `i`, `30`, `n`
   - If True → Node 3
   - Else → Node 7

3. **Node 3**: Assign `temp = Fnew`.
   - Def: `temp`
   - Use: `Fnew` (C-use)

4. **Node 4**: Compute `Fnew += Fold`.
   - Def: `Fnew`
   - Use: `Fnew`, `Fold` (both C-use)

5. **Node 5**: Assign `Fold = temp`.
   - Def: `Fold`
   - Use: `temp` (C-use from Node 3)

6. **Back to Node 2**: After Node 5, the loop continues by incrementing `i` and rechecking the condition at Node 2.

7. **Node 7**: Assign `ans = Fnew`.
   - Def: `ans`
   - Use: `Fnew` (C-use)

8. **Node 8**: Return `ans`.
   - Use: `ans`

The control flow transitions are as follows:

- From Node 1 to Node 2.
- If condition is True at Node 2, proceed through Nodes 3 →4 →5 and back to Node 2.
- If condition is False at Node 2, proceed to Node 7 and then Node 8.

This structure captures all control dependencies and data usages within the loop.

```code
int main() {
    int Fnew = 1;
    int Fold = 0;
    int temp;
    for (int i = 2; i <=30 && i <=n; i++) {
        temp = Fnew;
        Fnew += Fold;
        Fold = temp;
    }
    ans = Fnew;
    return ans;
}
```

The corresponding CFG nodes and edges are:

1. **Node 1** → **Node 2**
2. **Node 2** (if True) → **Node 3**
   - **Node 3** → **Node 4**
     - **Node 4** → **Node 5**
       - **Node 5** → **Node 2**
3. **Node 2** (if False) → **Node 7**
   - **Node 7** → **Node 8**

This graph accurately represents the program's control flow and data dependencies.