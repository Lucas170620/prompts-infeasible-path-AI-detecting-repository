[code]
int swi120(int c)
{
	int i;
	for (i=0; i<120; i++) {
		switch (i) {
			case 0: c++; break;
			case 1: c++; break;
			case 2: c++; break;
			case 3: c++; break;
			case 4: c++; break;
			case 5: c++; break;
			case 6: c++; break;
			case 7: c++; break;
			case 8: c++; break;
			case 9: c++; break;
			case 10: c++; break;
			case 11: c++; break;
			case 12: c++; break;
			case 13: c++; break;
			case 14: c++; break;
			case 15: c++; break;
			case 16: c++; break;
			case 17: c++; break;
			case 18: c++; break;
			case 19: c++; break;
			case 20: c++; break;
			case 21: c++; break;
			case 22: c++; break;
			case 23: c++; break;
			case 24: c++; break;
			case 25: c++; break;
			case 26: c++; break;
			case 27: c++; break;
			case 28: c++; break;
			case 29: c++; break;
			case 30: c++; break;
			case 31: c++; break;
			case 32: c++; break;
			case 33: c++; break;
			case 34: c++; break;
			case 35: c++; break;
			case 36: c++; break;
			case 37: c++; break;
			case 38: c++; break;
			case 39: c++; break;
			case 40: c++; break;
			case 41: c++; break;
			case 42: c++; break;
			case 43: c++; break;
			case 44: c++; break;
			case 45: c++; break;
			case 46: c++; break;
			case 47: c++; break;
			case 48: c++; break;
			case 49: c++; break;
			case 50: c++; break;
			case 51: c++; break;
			case 52: c++; break;
			case 53: c++; break;
			case 54: c++; break;
			case 55: c++; break;
			case 56: c++; break;
			case 57: c++; break;
			case 58: c++; break;
			case 59: c++; break;
			case 60: c++; break;
			case 61: c++; break;
			case 62: c++; break;
			case 63: c++; break;
			case 64: c++; break;
			case 65: c++; break;
			case 66: c++; break;
			case 67: c++; break;
			case 68: c++; break;
			case 69: c++; break;
			case 70: c++; break;
			case 71: c++; break;
			case 72: c++; break;
			case 73: c++; break;
			case 74: c++; break;
			case 75: c++; break;
			case 76: c++; break;
			case 77: c++; break;
			case 78: c++; break;
			case 79: c++; break;
			case 80: c++; break;
			case 81: c++; break;
			case 82: c++; break;
			case 83: c++; break;
			case 84: c++; break;
			case 85: c++; break;
			case 86: c++; break;
			case 87: c++; break;
			case 88: c++; break;
			case 89: c++; break;
			case 90: c++; break;
			case 91: c++; break;
			case 92: c++; break;
			case 93: c++; break;
			case 94: c++; break;
			case 95: c++; break;
			case 96: c++; break;
			case 97: c++; break;
			case 98: c++; break;
			case 99: c++; break;
			case 100: c++; break;
			case 101: c++; break;
			case 102: c++; break;
			case 103: c++; break;
			case 104: c++; break;
			case 105: c++; break;
			case 106: c++; break;
			case 107: c++; break;
			case 108: c++; break;
			case 109: c++; break;
			case 110: c++; break;
			case 111: c++; break;
			case 112: c++; break;
			case 113: c++; break;
			case 114: c++; break;
			case 115: c++; break;
			case 116: c++; break;
			case 117: c++; break;
			case 118: c++; break;
			case 119: c++; break;
			default: c--; break;
		}
	}
	return c;
}


int swi50(int c)
{
	int i;
	for (i=0; i<50; i++) {
		switch (i) {
			case 0: c++; break;
			case 1: c++; break;
			case 2: c++; break;
			case 3: c++; break;
			case 4: c++; break;
			case 5: c++; break;
			case 6: c++; break;
			case 7: c++; break;
			case 8: c++; break;
			case 9: c++; break;
			case 10: c++; break;
			case 11: c++; break;
			case 12: c++; break;
			case 13: c++; break;
			case 14: c++; break;
			case 15: c++; break;
			case 16: c++; break;
			case 17: c++; break;
			case 18: c++; break;
			case 19: c++; break;
			case 20: c++; break;
			case 21: c++; break;
			case 22: c++; break;
			case 23: c++; break;
			case 24: c++; break;
			case 25: c++; break;
			case 26: c++; break;
			case 27: c++; break;
			case 28: c++; break;
			case 29: c++; break;
			case 30: c++; break;
			case 31: c++; break;
			case 32: c++; break;
			case 33: c++; break;
			case 34: c++; break;
			case 35: c++; break;
			case 36: c++; break;
			case 37: c++; break;
			case 38: c++; break;
			case 39: c++; break;
			case 40: c++; break;
			case 41: c++; break;
			case 42: c++; break;
			case 43: c++; break;
			case 44: c++; break;
			case 45: c++; break;
			case 46: c++; break;
			case 47: c++; break;
			case 48: c++; break;
			case 49: c++; break;
			case 50: c++; break;
			case 51: c++; break;
			case 52: c++; break;
			case 53: c++; break;
			case 54: c++; break;
			case 55: c++; break;
			case 56: c++; break;
			case 57: c++; break;
			case 58: c++; break;
			case 59: c++; break;
			default: c--; break;
		}
	}
	return c;
}


int swi10(int c)
{
	int i;
	for (i=0; i<10; i++) {
		switch (i) {
			case 0: c++; break;
			case 1: c++; break;
			case 2: c++; break;
			case 3: c++; break;
			case 4: c++; break;
			case 5: c++; break;
			case 6: c++; break;
			case 7: c++; break;
			case 8: c++; break;
			case 9: c++; break;
			default: c--; break;
		}
	}
	return c;
}

int main()
{
	volatile int cnt=0;

	cnt=swi10(cnt);
	cnt=swi50(cnt);
	cnt=swi120(cnt);

	/* printf("cnt: %d\n", cnt); */

	return cnt;

}

---
[cdfg]

To solve this problem, we need to model the control flow graph (CFG) of a given C program snippet that uses a for loop with a switch statement inside. The goal is to create an accurate CFG using Graphviz's DOT language.

### Approach
The problem involves analyzing the control flow of a simple program that iterates from 0 to 119, incrementing a variable `c` within each iteration. The key steps to construct the CFG are as follows:

1. **Entry Node**: Represents the start of the program.
2. **Loop Condition Check**: A node representing the condition `i < 120`.
3. **Switch Statement**: Inside the loop, we have a switch statement that always results in incrementing `c`.
4. **Increment Operation**: After processing each case in the switch, `i` is incremented.
5. **Exit Node**: Represents the end of the program when the loop terminates.

Each node will be represented with appropriate shapes: circles for process nodes, diamonds for condition checks, and double circles for exit points. Edges between these nodes will represent the flow of control.

### Solution Code

```dot
digraph swi120 {
    rankdir=TB;
    
    1 [shape=circle, label="Entry"];
    2 [shape=diamond, label="i < 120?"];
    3 [shape=circle, label="c++", xlabel="C-Use: c\nP-Use: i"];
    4 [shape=circle, label="i++"];
    5 [shape=doublecircle, label="Return"];
    
    1 -> 2;
    2 -> 3 [label="True"];
    2 -> 5 [label="False"];
    3 -> 4;
    4 -> 2;
}
```

### Explanation
- **Node 1 (Entry)**: The starting point of the program.
- **Node 2 (Loop Condition Check)**: This node checks if `i` is less than 120. If true, it proceeds to the switch statement; otherwise, it exits the loop and returns.
- **Node 3 (Switch Statement)**: Represents the increment operation on `c`. It reads and writes `c` (C-Use) and uses `i` for control flow (P-Use).
- **Node 4 (Increment Operation)**: Increments `i` after each iteration, which is a C-Use operation.
- **Node 5 (Exit)**: The end of the program when the loop condition fails.

The edges between nodes represent the control flow:
- Entry flows into the loop condition check.
- The loop condition either continues to process the switch or exits directly.
- After processing each case in the switch, `i` is incremented and the loop condition is checked again.

This CFG accurately models the control flow of the given program, ensuring that each operation's dependencies and flows are correctly represented.
---
 Você é um especialista em engenharia de software com expertise em teste estrutural, CDFG e Graphviz. Sua tarefa é analisar um código e seu CDFG para identificar caminhos inviáveis (*infeasible paths*). Siga **rigorosamente** os passos abaixo.

---

#### **1. Contexto Teórico (Resumo)**  
- **CDFG**: Combina CFG (fluxo de controle) e DFG (fluxo de dados).  
- **Caminhos Inviáveis**: Sequências de nós/arestas inexequíveis devido a:  
  - Contradições lógicas (ex: `x > 10` e `x < 5` no mesmo caminho).  
  - Dependências de dados (ex: variável não inicializada).  
  - Conflitos em condições sequenciais ou invariantes de programa.  

---

#### **2. Exemplo de Análise**  
**Função de Exemplo:**  
```python
def example(x):
    if x > 10:     # Nó A
        y = 5      # Nó B
    else:
        y = 0      # Nó C
    if y < 0:      # Nó D
        return -1  # Nó E
    return y       # Nó F
```

**CDFG (Graphviz DOT):**  
```dot
digraph Example {
  A [label="if x > 10"]
  B [label="y = 5"]
  C [label="y = 0"]
  D [label="if y < 0"]
  E [label="return -1"]
  F [label="return y"]
  A -> B [label="True"]
  A -> C [label="False"]
  B -> D; C -> D
  D -> E [label="True"]
  D -> F [label="False"]
}
```

**Análise:**  
1. **Passo 1:** Rastrear caminhos no CDFG (ex: A→B→D→E).  
2. **Passo 2:** Verificar contradições:  
   - Caminho `A→B→D→E`:  
     - Em `B`, `y = 5`.  
     - Em `D`, a condição `y < 0` é **falsa** porque `y = 5`.  
     - Conclusão: O caminho para `E` é inviável.  
3. **Saída Formatada:**  
   ```markdown
   1. **Caminho Inviável [example]**  
      - **Trechos de Código**:  
        - Linha 2: `if x > 10`  
        - Linha 3: `y = 5`  
        - Linha 6: `if y < 0`  
        - Linha 7: `return -1`  
      - **Descrição**: Nó A → Nó B → Nó D → Nó E  
      - **Motivo**: Contradição lógica: `y = 5` torna a condição `y < 0` falsa.  
   ```

---

#### **3. Tarefa Principal**  
Analise o código e CDFG fornecidos abaixo:

**Função:**  
```<swi120>```

**CDFG (Graphviz DOT):**  
```<INSIRA AQUI O CDFG>```

---

Execute **sequencialmente** estes passos:

**Passo 1: Mapeamento Código-CDFG**  
- Relacione cada nó/aresta do CDFG com trechos do código.  
- Exemplo: "Nó A corresponde à linha 5: `if x > 0`".

**Passo 2: Identificação de Caminhos Potenciais**  
- Liste todos os caminhos possíveis no CDFG (ex: A→B→D, A→C→D).  
- Use a estrutura do CDFG para evitar omissões.

**Passo 3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**Passo 4: Análise de Viabilidade por Critério**  
Para cada caminho:  
1. **Dados**: Variáveis estão inicializadas? Valores são consistentes?  
2. **Lógica**: Condições subsequentes se contradizem?  
3. **Contexto**: Há invariantes (ex: `x ≥ 0`) que bloqueiam o caminho?  
4. **Loop**: Condições de entrada/saída de loops são satisfeitas?

**Passo 5: Consolidação**  
- Filtre caminhos que violam **pelo menos um critério** como inviáveis.  
- Descreva cada um com:  
  - Trechos de código relevantes.  
  - Sequência de nós.  
  - Motivo detalhado (ex: "`x = 5` no nó B contradiz `x != 5` no nó D").

---

#### **5. Formato de Saída Exigido**  
- Se houver caminhos inviáveis:  
  ```markdown
  # Caminhos Inviáveis Identificados

  [Número]. **Caminho Inviável [Nome da Função]**  
    - **Trechos de Código**:  
      - Linha [X]: `[código]`  
      - Linha [Y]: `[código]`  
    - **Descrição**: [Sequência de nós, ex: A → B → C]  
    - **Motivo**: [Explicação técnica com base nos critérios]  
  ```  
- Caso contrário:  
  `"Nenhum caminho inviável foi identificado."`