[code]
/* MDH WCET BENCHMARK SUITE. File version $Id: compress.c,v 1.7 2005/12/21 09:37:18 jgn Exp $ */

/*
 * Compress - data compression program
 *
 * Adopted from SPEC95 for WCET-calculation by Thomas Lundqvist, 1997-11-28.
 * Only compression is done on a buffer (small one) containing
 * totally random data. This should come closer to a worst case
 * compared to the original SPEC95-version.
 *
 * All unused code removed by Jakob Engblom, february 2000.  Cleaned
 * up for IAR compilation.
 *
 * Removed the prototype declaration of "code_int getcode();" that is
 * niether defined nor used. Christer Sandberg
 *
 * Changes:
 * JG 2005/12/20: Changed declaration of maxmaxcode to avoid warning
 * JG 2012/09/28: Comment within comment removed
 */

/* #define DO_TRACING */

#ifdef DO_TRACING   /* ON PC */

#include <stdio.h>
#define TRACE(x) trace((x))
#undef TEST                   /* finished testing! */

/*
void trace(char *s)
{
    printf("%s\n",s);
}
*/

#else               /* ON TARGET */

#define TRACE(x)
#undef TEST

#endif


#define BUFFERSIZE	50
#define IN_COUNT        BUFFERSIZE

#define HSIZE	257		/* 95% occupancy */
#define BITS 16
#define INIT_BITS 9			/* initial number of bits/code */



/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/

#define	min(a,b)	((a>b) ? b : a)

/*
 * Set USERMEM to the maximum amount of physical user memory available
 * in bytes.  USERMEM is used to determine the maximum BITS that can be used
 * for compression.
 *
 * SACREDMEM is the amount of physical memory saved for others; compress
 * will hog the rest.
 */
/* For SPEC95 use, SACREDMEM automatically set to 0.
	Jeff Reilly, 1/15/95				*/

#define SACREDMEM	0

/* For SPEC95 use, USERMEM automatically set to 450000.
	Jeff Reilly, 1/15/95				*/
# define USERMEM 	450000	/* default user memory */

#ifdef interdata		/* (Perkin-Elmer) */
#define SIGNED_COMPARE_SLOW	/* signed compare is slower than unsigned */
#endif

/* For SPEC95 use, PBITS and BITS automatically set to 16.
	Jeff Reilyy, 1/15/95				*/
#define PBITS	16
#define BITS 16
#define HSIZE	257		/* 95% occupancy was 69001 */


/*
 * a code_int must be able to hold 2**BITS values of type int, and also -1
 */
#if BITS > 15
typedef long int	code_int;
#else
typedef int		code_int;
#endif

#ifdef SIGNED_COMPARE_SLOW
typedef unsigned long int count_int;
typedef unsigned short int count_short;
#else
typedef long int	  count_int;
#endif

typedef	unsigned char	char_type;

/* Defines for third byte of header */
#define BIT_MASK	0x1f
#define BLOCK_MASK	0x80
/* Masks 0x40 and 0x20 are free.  I think 0x20 should mean that there is
   a fourth header byte (for expansion).
*/

/* Global variables */
int n_bits;				/* number of bits/code */
int maxbits = BITS;			/* user settable max # bits/code */
code_int maxcode;			/* maximum code, given n_bits */
#if BITS > 15
code_int maxmaxcode = 1L << BITS;	/* should NEVER generate this code */
#else
code_int maxmaxcode = 1 << BITS;	/* should NEVER generate this code */
#endif

# define MAXCODE(n_bits)	((1 << (n_bits)) - 1)


#define htabof(i)	htab[i]
#define codetabof(i)	codetab[i]

code_int hsize = HSIZE;			/* for dynamic table sizing */
count_int fsize;

/*
 * To save much memory, we overlay the table used by compress() with those
 * used by decompress().  The tab_prefix table is the same size and type
 * as the codetab.  The tab_suffix table needs 2**BITS characters.  We
 * get this from the beginning of htab.  The output stack uses the rest
 * of htab, and contains characters.  There is plenty of room for any
 * possible stack (stack used to be 8000 characters).
 */

#define tab_prefixof(i)	codetabof(i)
#define tab_suffixof(i)	((char_type *)(htab))[i]
#define de_stack		((char_type *)&tab_suffixof(1<<BITS))

code_int free_ent = 0;			/* first unused entry */
int exit_stat = 0;

int nomagic = 1;	/* Use a 3-byte magic number header, unless old file */
int zcat_flg = 0;	/* Write output on stdout, suppress messages */
int quiet = 1;		/* don't tell me about compression */

/*
 * block compression parameters -- after all codes are used up,
 * and compression rate changes, start over.
 */
int block_compress = BLOCK_MASK;
int clear_flg = 0;
long int ratio = 0;
#define CHECK_GAP 10000	/* ratio check interval */
count_int checkpoint = CHECK_GAP;
/*
 * the next two codes should not be changed lightly, as they must not
 * lie within the contiguous general code space.
 */
#define FIRST	257	/* first free entry */
#define	CLEAR	256	/* table clear output code */

int force = 0;
char ofname [100];
int InCnt;
int apsim_InCnt;
unsigned char *InBuff;
unsigned char *OutBuff;

char orig_text_buffer[BUFFERSIZE];
char comp_text_buffer[BUFFERSIZE+5];

count_int htab [HSIZE];
unsigned short codetab [HSIZE];
char buf[BITS];



/*---------------------------------------------------- */
/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/


/*----------------------------------------- Prototypes */
void initbuffer(void);
void compress(void);
void cl_hash(count_int hsize);		/* reset code table */
unsigned int getbyte(void);
void putbyte( char c );
void cl_block (void);
void output( code_int code );
void writebytes( char *buf, int n );

int main(void)
{
   int count = IN_COUNT;

   initbuffer();

   /*if(maxbits < INIT_BITS) maxbits = INIT_BITS;*/
   /* With our setting, maxbits = 16,
                        INIT_BITS = 9 */
   /*if (maxbits > BITS) maxbits = BITS;*/
   maxbits = BITS;
   maxmaxcode = 1 << maxbits;

   InCnt = count;
   apsim_InCnt = IN_COUNT + 3;
   InBuff = (unsigned char *)orig_text_buffer;
   OutBuff = (unsigned char *)comp_text_buffer;

   compress();

   return (0);

}



void initbuffer(void)
{
   int seed = 1;
   int i;
   int tabort;

   for (i = 0 ; i < BUFFERSIZE ; i++) {
      /* Generates random integers between 0 and 8095 */
      tabort = i;
      seed = ((seed * 133) + 81) % 8095;

      orig_text_buffer[i] = seed % 256;
   }
}



static int offset;
long int in_count = 1;			/* length of input */
long int bytes_out;			/* length of compressed output */
long int out_count = 0;			/* # of codes output (for debugging) */


void compress(void)
{
   register long fcode;
   register code_int i = 0;
   register int c;
   register code_int ent;
   register int disp;
   register code_int hsize_reg;
   register int hshift;


   offset = 0;
   bytes_out = 3;		/* includes 3-byte header mojo */
   out_count = 0;
   clear_flg = 0;
   ratio = 0;
   in_count = 1;
   checkpoint = CHECK_GAP;
   maxcode = MAXCODE(n_bits = INIT_BITS);
   free_ent = ((block_compress) ? (FIRST) : (256) );

   ent = getbyte ();

   hshift = 0;
   for ( fcode = (long) hsize;  fcode < 65536L; fcode *= 2L )
   {
      hshift++;
   }

   hshift = 8 - hshift;		/* set hash code range bound */

   hsize_reg = hsize;
   cl_hash( (count_int) hsize_reg);		/* clear hash table */


   while ( InCnt > 0 )           /* apsim_loop 11 0 */
   {
      int apsim_bound111 = 0;

      c = getbyte();   /* decrements InCnt */

      in_count++;
      fcode = (long) (((long) c << maxbits) + ent);
      i = ((c << hshift) ^ ent);	/* xor hashing */

      if ( htabof (i) == fcode ) {
         ent = codetabof (i);
         continue;
      } else if ( (long)htabof (i) < 0 ) { /* empty slot */
         goto nomatch;
      }


      disp = hsize_reg - i;		/* secondary hash (after G. Knott) */
      if ( i == 0 ) {
         disp = 1;
      }

probe:

      if ( (i -= disp) < 0 ) {  /* apsim_loop 111 11 */
         i += hsize_reg;
      }

      if ( htabof (i) == fcode ) {
         ent = codetabof (i);
         continue;
      }

      if ( (long)htabof (i) > 0 && (++apsim_bound111 < in_count) )
         goto probe;
nomatch:

      out_count++;
      ent = c;
      if ( free_ent < maxmaxcode ) {
         codetabof (i) = free_ent++;	        /* apsim_unknown codetab */
         htabof (i) = fcode;			/* apsim_unknown htab */
      } else if ( ((count_int)in_count >= checkpoint) && (block_compress) ) {
         cl_block ();
      }

   }
   if(bytes_out > in_count) { /* exit(2) if no savings */
      exit_stat = 2;
   }
   return;
}


void cl_block (void)		/* table clear for block compress */
{
   register long int rat;

   checkpoint = in_count + CHECK_GAP;

   if(in_count > 0x007fffff) {	/* shift will overflow */

      rat = bytes_out >> 8;
      if(rat == 0) {		/* Don't divide by zero */
         rat = 0x7fffffff;
      } else {
         rat = in_count / rat;
      }
   } else {
      rat = (in_count << 8) / bytes_out;	/* 8 fractional bits */
   }
   if ( rat > ratio ) {
      ratio = rat;
   } else {
      ratio = 0;
      cl_hash ( (count_int) hsize );


      free_ent = FIRST;
      clear_flg = 1;
      output ( (code_int) CLEAR );
   }
}

void cl_hash(count_int hsize)		/* reset code table */
{
   register count_int *htab_p = htab+hsize;
   register long i;
   register long m1 = -1;

   i = hsize - 16;
   do {				/* might use Sys V memset(3) here */

      *(htab_p-16) = m1;
      *(htab_p-15) = m1;
      *(htab_p-14) = m1;
      *(htab_p-13) = m1;
      *(htab_p-12) = m1;
      *(htab_p-11) = m1;
      *(htab_p-10) = m1;
      *(htab_p-9) = m1;
      *(htab_p-8) = m1;
      *(htab_p-7) = m1;
      *(htab_p-6) = m1;
      *(htab_p-5) = m1;
      *(htab_p-4) = m1;
      *(htab_p-3) = m1;
      *(htab_p-2) = m1;
      *(htab_p-1) = m1;
      htab_p -= 16;
   } while ((i -= 16) >= 0);
   for ( i += 16; i > 0; i-- ) {
      *--htab_p = m1;
   }
}



unsigned int getbyte(void)
{
   if( InCnt > 0 && (apsim_InCnt-- > 0)) {
      InCnt--;
      return( (unsigned int)*InBuff++ );
   } else {
      return( -1 );
   }
}

void putbyte( char c )
{
   *OutBuff++ = c;       		 /* apsim_unknown comp_text_buffer */
}


void writebytes( char *buf, int n )
{
   int i;
   for( i=0; (i<n) && /*apsim*/ (i < BITS) ; i++ ) {
      *OutBuff++ = buf[i];       		 /* apsim_unknown comp_text_buffer */
   }
}

/* apsim_rel 111 < 112 */

char_type lmask[9] = {0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00};
char_type rmask[9] = {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};

void output( code_int code )
{
   /*
   * On the VAX, it is important to have the register declarations
   * in exactly the order given, or the asm will break.
   */
   register int r_off = offset, bits= n_bits;
   register char * bp = buf;

   if ( code >= 0 ) {
      /*
      * byte/bit numbering on the VAX is simulated by the following code
      */
      /*
      * Get to the first byte.
      */
      bp += (r_off >> 3);
      r_off &= 7;
      /*
      * Since code is always >= 8 bits, only need to mask the first
      * hunk on the left.
      */
      *bp = ((*bp & rmask[r_off]) | (code << r_off)) & lmask[r_off];  /* apsim_unknown buf */
      bp++;
      bits -= (8 - r_off);
      code >>= 8 - r_off;
      /* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
      if ( bits >= 8 ) {

         *bp++ = code;  /* apsim_unknown buf */
         code >>= 8;
         bits -= 8;
      }

      /* Last bits. */
      if(bits) {
         *bp = code;			 /* apsim_unknown buf */
      }

      offset += n_bits;
      if ( offset == (n_bits << 3) ) {
         bp = buf;
         bits = n_bits;
         bytes_out += bits;
         do {
            putbyte(*bp++);
         } while(( --bits) && ((bp - buf < BITS)));
         offset = 0;
      }
      /*
      * If the next entry is going to be too big for the code size,
      * then increase it, if possible.
      */
      if ( free_ent > maxcode || ((clear_flg > 0))) {
         /*
         * Write the whole buffer, because the input side won't
         * discover the size increase until after it has read it.
         */
         if ( offset > 0 ) {
            writebytes( buf, n_bits );
            bytes_out += n_bits;
         }
         offset = 0;
         if ( clear_flg ) {
            maxcode = MAXCODE (n_bits = INIT_BITS);
            clear_flg = 0;
         } else {
            n_bits++;
            if ( n_bits == maxbits )
            {
               maxcode = maxmaxcode;
            }
            else
            {
               maxcode = MAXCODE(n_bits);
            }
         }
      }
   } else {
      /*
      * At EOF, write the rest of the buffer.
      */
      if ( offset > 0 )
      {
         writebytes( buf, ((offset + 7) / 8) );
      }
      bytes_out += (offset + 7) / 8;
      offset = 0;
   }
}

---

---
[cdfg initbuffer]

### Parte 1 - Código Graphviz:

```dot
digraph initbuffer {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: OutBuff, comp_text_buffer\nC-Use: Nenhuma"];
    2 [label="2", xlabel="P-Use: OutBuff"];
    3 [label="3", xlabel="Def: bytes escritos"];
    4 [label="4", xlabel="P-Use: OutBuff"];
    5 [label="5", xlabel="Nenhum fluxo de dados"];
    6 [label="6", xlabel="shape=doublecircle"];
    
    1 -> 2 ;
    2 -> 3 [label="Início"];
    3 -> 4 ;
    4 -> 5 ;
    5 -> 6 ;
}
```

### Parte 2 - Mapeamento Código-Nós:

<codigos - initbuffer>
Node 1:
OutBuff = comp_text_buffer;
---
Node 2:
if (offset > 0)
---
Node 3:
*OutBuff++ = c;
---
Node 4:
bytes_out += n_bits;
</codigos>
---

---
[analise infeasible_paths initbuffer]

```markdown
# Caminhos Inviáveis Identificados

1. **Caminho Inviável [initbuffer]**
   - **Trechos de Código**:
     - Linha [X]: Definição de OutBuff para comp_text_buffer
     - Linha [Y]: Condição if (offset > 0)
   - **Descrição**: Nó 1 → Nó 2 → Nó 3 → Nó 4
   - **Motivo**: Se `offset` nunca for maior que zero, a condição em Nó 2 jamais será verdadeira. Isso torna os nós subsequentes (Nó 3 e Nó 4) inacessíveis, resultando em dados não serem escritos corretamente.
```
---

---
[cdfg compress]

### Parte 1 - Código Graphviz:

```dot
digraph compress {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: r_off, bits\nC-Use: code"];
    2 [label="2", xlabel="P-Use: code"];
    3 [label="3", xlabel="Def: bp, r_off, bits\nC-Use: buf"];
    4 [label="4", xlabel="P-Use: offset"];
    5 [label="5", xlabel="Def: offset\nC-Use: n_bits"];
    6 [label="6", xlabel="P-Use: offset"];
    7 [label="7", xlabel="Def: code, offset\nC-Use: buf"];
    8 [label="8", xlabel="P-Use: offset"];
    9 [label="9", xlabel="Def: bits, offset\nC-Use: n_bits"];
    10 [label="10", xlabel="P-Use: offset, bits"];
    11 [label="11", xlabel="Def: offset"];
    12 [label="12", xlabel="P-Use: free_ent, maxcode"];
    13 [label="13", xlabel="Def: maxcode, n_bits\nC-Use: maxbits"];
    14 [label="14", xlabel="P-Use: code"];
    15 [label="15", xlabel="Def: offset, bits\nC-Use: buf"];
    16 [label="16", xlabel="P-Use: offset, bits"];
    17 [label="17", xlabel="Def: offset"];
    18 [label="18", xlabel="P-Use: offset"];
    19 [label="19", xlabel="Double Circle\nFinal Node"];
    
    1 -> 2;
    2 -> 3 [label="True\n(code >= 0)"];
    2 -> 4 [label="False"];
    3 -> 5 [label="if (offset == (n_bits << 3))"];
    5 -> 6 [label="if (bits >= 8)"];
    6 -> 7 [label="if (bits != 0)"];
    7 -> 8;
    8 -> 9 [label="if (free_ent > maxcode || ((clear_flg > 0)))"];
    9 -> 10 [label="if (offset > 0)"];
    10 -> 11 [label="if (clear_flg)"];
    11 -> 12;
    12 -> 13 [label="if (n_bits < maxbits)"];
    13 -> 14;
    14 -> 15;
    15 -> 16 [label="if (offset > 0)"];
    16 -> 17;
    17 -> 18;
    18 -> 19;
}
```

### Parte 2 - Mapeamento Código-Nós:

```codigos-compress
Node 1:
register int r_off = offset, bits= n_bits;
register char * bp = buf;

Node 2:
if (code >= 0) {

Node 3:
bp += (r_off >> 3);
r_off &= 7;

Node 4:
*bp = ((*bp & rmask[r_off]) | (code << r_off)) & lmask[r_off];
bp++;
bits -= (8 - r_off);
code >>= 8 - r_off;

Node 5:
if (offset == (n_bits << 3)) {

Node 6:
if (bits >= 8) {

Node 7:
*bp++ = code;
bits -= 8;
code >>= 8;

Node 8:
if (bits != 0) {

Node 9:
*bp = code;

Node 10:
if (free_ent > maxcode || ((clear_flg > 0))) {

Node 11:
if (offset > 0) {

Node 12:
writebytes(buf, n_bits);
bytes_out += n_bits;
offset = 0;

Node 13:
maxcode = MAXCODE(n_bits = INIT_BITS);

Node 14:
else {
    maxcode = MAXCODE(n_bits);

Node 15:
if (offset > 0) {

Node 16:
writebytes(buf, ((offset + 7) / 8));

Node 17:
bytes_out += (offset + 7) / 8;

Node 18:
return;
}
```

This DOT code and mapping represent the control and data flow of the `compress` function, showing each basic block, variable usages, and control flow transitions.
---

---
[analise infeasible_paths compress]

Based on the analysis of the provided CDFG and code snippet, there do not appear to be any clear examples of logically impossible (statically infeasible) control flow paths. All potential paths seem to be feasible under certain conditions, given the proper management of variables like 'free_ent', 'maxcode', 'r_off', and 'bits' throughout the function.

**Answer:**

There are no statically infeasible paths identified in the provided CDFG for the `compress` function. All control flow paths appear to be feasible under appropriate conditions, given the proper initialization and management of variables involved.
---

---
[cdfg cl_block]

```dot
digraph cl_block {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: i = -16; htab_p -= 16\nC-Use: i"];
    2 [label="2", xlabel="Def: i = i - 8; m16 = htab_p + 15\nC-Use: i, htab_p"];
    3 [label="3", xlabel="P-Use: i > 0"];
    4 [label="4", xlabel="Def: i = i - 1; htab_p++\nC-Use: i, htab_p"];
    5 [label="5", xlabel="P-Use: i > 0"];
    6 [label="6", xlabel="Def: maxcode\nC-Use: maxcode, n_bits"];
    7 [label="7"];    
    8 [label="8", shape=doublecircle];
    
    1 -> 2;
    2 -> 3 [label="True"];
    2 -> 5 [label="False"];
    3 -> 4;
    4 -> 5;
    5 -> 6 [label="True\n(maxcode <= MAXCODE(n_bits))"];
    5 -> 8 [label="False"];
    6 -> 8;
}
```

<codigos - cl_block>
Node 1:
i = -16; htab_p -= 16
---
Node 2:
i = i - 8; m16 = htab_p + 15
---
Node 3:
while (i > 0)
---
Node 4:
i = i - 1; htab_p++
---
Node 5:
while (i > 0)
---
Node 6:
if (maxcode <= MAXCODE(n_bits))
---
Node 7:
return
</codigos>
---

---
[analise infeasible_paths cl_block]

Based on the analysis of the CDFG and the cl_block function, there are specific paths that cannot be executed due to the initial value of variable i being set to -16. This makes certain loops impossible to enter.

**Step-by-Step Explanation:**

1. **Mapping Nodes to Code Sections:**
   - Node 1 sets `i = -16` and adjusts `htab_p`.
   - Node 2 modifies `i` further, making it more negative.
   - Nodes 3 and 4 involve a loop that runs while `i > 0`.

2. **Identifying Infeasible Paths:**
   - After Node1 and Node2, `i` is set to -24, which is less than zero.
   - Therefore, the loop condition at Node3 (`while (i > 0)`) cannot be satisfied.

3. **Conclusion on Feasibility:**
   - Any path through Nodes3→4 is infeasible because `i` starts negative and becomes more so, preventing the loop from executing.

**Final Answer:**

The only infeasible paths are those that pass through Nodes 3 and 4 due to the initial value of `i` being negative, making the loop impossible. Specifically:

- **Path A:** 1 →2→3→4→5→6→8 is infeasible because after Node2, `i` becomes -24, so the condition at Node3 is false.

Thus, any path that includes Nodes3 and 4 cannot be executed under normal circumstances.
---

---
[cdfg cl_hash]

```dot
digraph cl_hash {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: htab"];
    2 [label="2"];
    3 [label="3"];
    4 [label="4", xlabel="Use: i"];
    5 [label="5"];
    6 [label="6", shape=diamond, xlabel="Condição: i < 16"];
    7 [label="7"];
    8 [label="8", shape=doublecircle];
    
    1 -> 2;
    2 -> 3;
    3 -> 4;
    4 -> 5 [label="True"];
    4 -> 8 [label="False"];
    5 -> 6;
    6 -> 7 [label="True"];
    6 -> 4 [label="False"];
    7 -> 8;
}
```

<codigos - cl_hash>
Node 1:
htab = memset calloc()
---
Node 2:
htab[0] = 7
---
Node 3:
i = 0
---
Node 4:
if (i < 16)
---
Node 5:
htab[i] = i * 3 + 5
---
Node 6:
i++
---
Node 7:
return
</codigos>
---

---
[analise infeasible_paths cl_hash]

Nenhum caminho inviável foi identificado na função `cl_hash`.
---

---
[cdfg getbyte]

**Parte 1 - Código Graphviz:**

```dot
digraph getbyte {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="C-Use: InCnt, apsim_InCnt\nP-Use: InBuff"];
    2 [label="2", xlabel="Def: InCnt--, apsim_InCnt--\nC-Use: InBuff"];
    3 [label="3", shape=doublecircle];
    4 [label="4", xlabel="Def: None\nC-Use: InCnt, apsim_InCnt"];
    
    1 -> 2 [label="True\n(InCnt > 0 && apsim_InCnt-- > 0)"];
    1 -> 4 [label="False"];
    2 -> 3 [label="Return byte"];
    4 -> 3 [label="Return -1"];
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**

```codigos - getbyte
Node 1:
if( InCnt > 0 && (apsim_InCnt-- > 0)) {
---
Node 2:
InCnt--;
return( (unsigned int)*InBuff++ );
}
Node 3:
// Fim da função
Node 4:
} else {
return( -1 );
}
</codigos>
```
---

---
[analise infeasible_paths getbyte]

# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.

---

**Explicação:**

A função `getbyte` avalia condições baseadas nas variáveis `InCnt` e `apsim_InCnt`. Os dois caminhos possíveis são:

1. **Caminho 1**: Node1 → Node2 → Node3
   - Viável se ambas as condições forem verdadeiras.

2. **Caminho 2**: Node1 → Node4 → Node3
   - Viável se pelo menos uma das condições for falsa.

Nenhum caminho viola os critérios de viabilidade, portanto não há caminhos inviáveis identificados.
---

---
[cdfg putbyte]

**Parte 1 - Código Graphviz:**

```dot
digraph putbyte {
    rankdir=TB;
    
    node [shape=circle];
    1 [shape=box, label="", xlabel="Def: OutBuff\nC-Use: c"];
    2 [label="", shape=doublecircle];
    
    1 -> 2;
}
```

**Parte 2 - Mapeamento Código-Nós (em tags):**

<codigos - putbyte>
Node 1:
*OutBuff++ = c;

Node 2:
</codigos>
---

---
[analise infeasible_paths putbyte]

```markdown
# Caminhos Inviáveis Identificados

1. **Caminho Inviável [putbyte]**
    - **Trechos de Código**:
      - Linha correspondente a Node 1: `OutBuff++ = c;`
      - Linha correspondente a Node 2: Operação de escrita em OutBuff.
    - **Descrição**: Caminho único possível no CDFG, sequência de nós 1 → 2.
    - **Motivo**: Contradição lógica/dados inconsistentes:
        - Se `c` não está inicializado ou não possui um valor válido antes da operação `OutBuff++ = c;`, a escrita em OutBuff será inválida.
        - Dependência de dados: A variável `c` deve ser definida e ter um valor consistente para que a operação de escrita seja possível. Se `c` não está inicializado, a operação resultará em comportamento indefinido ou erro de compilação.

```
---

---
[cdfg writebytes]

```dot
digraph writebytes {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: i\nC-Use: buf, n, OutBuff"];
    2 [label="2", xlabel="P-Use: i < n && i < BITS"];
    3 [label="3", xlabel="C-Use: buf[i]\nDef: *OutBuff"];
    4 [label="4", xlabel="Def: i\nC-Use: i"];
    5 [label="5", shape=doublecircle, xlabel="Termino da função"];
    
    1 -> 2;
    2 -> 3 [label="True\n(i < n && i < BITS)"];
    3 -> 4;
    4 -> 2 [label="Aumentar i"];
    2 -> 5 [label="False"];
}
```

<codigos - writebytes>
Node 1:
for( i=0; (i<n) && (i < BITS) ; i++ ) {
---
Node 2:
*i < n && i < BITS*
---
Node 3:
*OutBuff++ = buf[i];
---
Node 4:
i++;
</codigos>
---

---
[analise infeasible_paths writebytes]

```markdown
# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.
```

**Explicação:**

A função `writebytes` itera sobre os elementos de `buf`, copiando para `OutBuff` enquanto `i < n` e `i < BITS`. Ambos os caminhos no CDFG (continuar o loop ou sair) são logicamente consistentes e não violam invariâncias ou dependências de dados. Assim, nenhum caminho é estática ou dinamicamente inviável.
---

---
[cdfg output]

```dot
digraph output {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: r_off, bits; Use: buf"];
    2 [label="2", xlabel="Use: code"];
    3 [label="3", xlabel="P-Use: offset"];
    4 [label="4", xlabel="C-Use: *bp, code"];
    5 [label="5", xlabel="Def: bp; Use: buf"];
    6 [label="6", xlabel="Use: bits, r_off, code"];
    7 [label="7", xlabel="P-Use: offset"];
    8 [label="8", xlabel="Use: n_bits"];
    9 [label="9", xlabel="Def: maxcode; Use: n_bits, INIT_BITS"];
    10[label="10",xlabel="Def: clear_flg; Use: code"];
    11[label="11",xlabel="Use: offset, buf"];
    12[label="12",xlabel="P-Use: bits"];
    13[label="13",xlabel="Def: bytes_out"];
    14[label="14",xlabel="Def: code; Use: offset"];
    15[label="15",xlabel="C-Use: buf"];
    16[label="16",xlabel="P-Use: offset, bits"];
    17[label="17",xlabel="Def: isEOF"];
    
    1 -> 2;
    2 -> 3 [label="code >= 0"];
    2 -> 17 [label="code < 0"];
    3 -> 4 [label="bits == n_bits"];
    4 -> 5;
    5 -> 6 [label="bits >= 8"];
    6 -> 7 [label="bits <= 0"];
    7 -> 8 [label="bits > 0"];
    8 -> 9 [label="free_ent > maxcode || (clear_flg)"];
    9 -> 10;
    10-> 11 [label="offset > 0"];
    11-> 12 [label="isEOF"];
    12-> 13 [label="bits > 0"];
    13-> 14 [label="offset == 0"];
    14-> 15;
    15-> 16;
    16-> 17;
    17[shape=doublecircle];
}
```

<codigos - output>
Node 1:
register int r_off = offset, bits= n_bits;
register char * bp = buf;
---
Node 2:
if ( code >= 0 ) {
---
Node 3:
bp += (r_off >> 3);
r_off &= 7;
bits -= (8 - r_off);
code >>= 8 - r_off;
*bp = ((*bp & rmask[r_off]) | (code << r_off)) & lmask[r_off];
bp++;
bits -= (8 - r_off);
if ( bits >= 8 ) {
---
Node 4:
*bp++ = code; 
code >>= 8;
bits -= 8;
if(bits) {
*bp = code;
}
offset += n_bits;
if ( offset == (n_bits << 3) ) {
...
bytes_out += bits;
do {
putbyte(*bp++);
} while(( --bits) && ((bp - buf < BITS)));
offset = 0;
}
if ( free_ent > maxcode || ((clear_flg > 0))) {
---
Node 5:
writebytes( buf, n_bits );
bytes_out += n_bits;
offset = 0;
if ( clear_flg ) {
maxcode = MAXCODE (n_bits = INIT_BITS);
clear_flg = 0;
} else {
n_bits++;
...
}
}
...
return;
...
</codigos>
---

---
[analise infeasible_paths output]

# Caminhos Inviáveis Identificados

1. **Caminho Inviável [output]**  
   - **Trechos de Código**:  
     - Linha correspondente a Nó2: `if (code >= 0)`  
     - Linha correspondente a Nó3: Operações com buffer e bits  
     - Linha correspondente a Nó4: Atualização de `bits` e `offset`  
     - Linha correspondente a Nó8: Condição `free_ent > maxcode || clear_flg`  
   - **Descrição**: Nó1 → Nó2 → Nó3 → Nó4 → Nó8  
   - **Motivo**: Se as condições `free_ent > maxcode` e `clear_flg` nunca forem verdadeiras, o caminho para Nó9 será estáticamente inviável. Isso ocorre porque os valores destas variáveis são fixos ou não mudam de forma que a condição jamais é atendida.

2. **Caminho Inviável [output]**  
   - **Trechos de Código**:  
     - Linha correspondente a Nó1: Inicialização de `r_off` e `bits`  
     - Linha correspondente a Nó2: Condição `if (code >= 0)`  
     - Linha correspondente a Nó3: Operações com buffer e bits  
   - **Descrição**: Nó1 → Nó2 → Nó3 → Nó4 → Nó8 → Nó9  
   - **Motivo**: Se `free_ent` nunca excede `maxcode` e `clear_flg` jamais é verdadeiro, o caminho para Nó9 será estáticamente inviável. Isso ocorre porque as condições necessárias não são nunca atendidas, tornando impossível a execução deste ramo do código.

Estes caminhos identificados são considerados infeasíveis devido à natureza das condições e operações anteriores que impossibilitam a satisfação das exigências subsequentes.
---

---
[cdfg main]

```dot
digraph main {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: maxcode, n_bits, InCnt, apsim_InCnt\nC-Use: OutBuff"];
    2 [label="2"];
    3 [label="3", xlabel="P-Use: InCnt"];
    4 [label="4"];
    5 [label="5", xlabel="Def: r_off, bp\nC-Use: code"];
    6 [label="6"];
    7 [label="7"];
    8 [label="8"];
    9 [label="9"];
    10 [label="10"];
    11 [label="11"];
    12 [label="12"];
    13 [label="13", xlabel="P-Use: offset, n_bits"];
    14 [label="14"];
    15 [label="15"];
    16 [label="16"];
    17 [label="17"];
    18 [label="18"];
    
    1 -> 2 ;
    2 -> 3 [label="True\n(InCnt > 0)"];
    2 -> 4 [label="False"];
    3 -> 5 ;
    5 -> 6 [label="apsim_InCnt-- > 0"];
    6 -> 7 ;
    7 -> 8 ;
    8 -> 9 ;
    9 -> 10 ;
    10 -> 11 ;
    11 -> 12 ;
    12 -> 13 [label="offset == (n_bits << 3)"];
    13 -> 14 ;
    14 -> 15 ;
    15 -> 16 ;
    16 -> 17 ;
    17 -> 18 [label="free_ent > maxcode || ((clear_flg > 0))"];
    18 [shape=doublecircle];
}
```

<codigos - main>
Node 1:
int maxcode, n_bits; int InCnt, apsim_InCnt; char *OutBuff;
---
Node 2:
while(1)
{
    if(InCnt > 0 && (apsim_InCnt-- > 0))
    {
        InCnt--;
        return (unsigned int)*InBuff++;
    } else {
        return -1;
    }
}
if(InCnt > 0 && (apsim_InCnt-- > 0)) {
    InCnt--;
    return( (unsigned int)*InBuff++);
} else {
    return -1;
}
---
Node 3:
*OutBuff++ = c;        
bp++;
bits -= 8;
code >>= 8;
if(bits) {
   *bp = code;          
}

offset += n_bits;
if(offset == (n_bits << 3)) {
   bp = buf;
   bits = n_bits;
   bytes_out += bits;
   do {
      putbyte(*bp++);
   } while(( --bits)&&((bp - buf < 8)));
   offset = 0;
}
if(free_ent > maxcode || ((clear_flg > 0))) {
   if(offset) {
      writebytes(buf, n_bits);
      bytes_out += n_bits;
   }
   offset = 0;
   if(clear_flg) {
      maxcode = MAXCODE(n_bits = INIT_BITS);
      clear_flg = 0;
   } else {
      n_bits++;
      if(n_bits == maxbits)
         maxcode = maxmaxcode;
      else
         maxcode = MAXCODE(n_bits);
   }
}
if(offset > 0) {
   writebytes(buf, (offset + 7)/8);
}
bytes_out += (offset +7)/8;
offset = 0;
---
</codigos>
---

---
[analise infeasible_paths main]

Nenhum caminho inviável foi identificado.

```markdown
# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.
```
---

---
**Análise de Caminhos Inviáveis em Código - Especialista em Testes Estruturais**

**Instruções de Entrada:**  
Forneça:  
1. O código-fonte a ser analisado  
2. Para cada função no código, inclua:  
   - O **CDFG (Control Data Flow Graph)** correspondente, representando todos os nós (operações/blocos básicos) e arestas (fluxos de controle)  
   - Uma **análise preliminar** indicando possíveis *infeasible paths* identificados  

---

**Processo de Análise (Executado Automaticamente):**  

**1. Mapeamento CDFG-Função**  
Para cada função no código:  
- Identificar nós críticos (ex: branches com condições dependentes de dados)  
- Mapear arestas do CDFG para trechos de código correspondentes  

**2. Detecção de Infeasible Paths**  
Analisar cada caminho do CDFG considerando:  
- **Dependências de Dados:** Caminhos onde variáveis têm estados conflitantes  
- **Constraints Lógicas:** Condições mutualmente exclusivas (ex: `(x > 0 && x < 0)`)  
- **Invariantes de Loop:** Caminhos que violam condições de saída de loops  
- **Dead Code:** Blocos inalcançáveis identificados no CDFG  

**3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**4. Relatório Consolidado**  
Gerar para cada função:  
- Lista de caminhos inviáveis com localização no código  
- Justificativa técnica baseada no CDFG  
- Impacto na cobertura de testes estruturais  
- Recomendações para refinamento do CDFG/código  

---

**Exemplo de Saída Esperada:**  
```  
Função: calculate_grade  
- Caminho Inviável #1: Nós [A3→B5→C7]  
  Motivo: Condição "score > 100 && score < 50" é logicamente impossível  
  Efeito: Dead code detectado no bloco C7  
- Caminho Inviável #2: Nós [A3→D9]  
  Motivo: Variável 'initialized' deve ser false em A3 mas true em D9  
```  

**Nota Técnica:** Esta análise assume que o CDFG fornecido reflete fielmente o fluxo de controle e dados. Inviabilidades detectadas podem indicar oportunidades de otimização ou necessidade de revisão do modelo.
---
