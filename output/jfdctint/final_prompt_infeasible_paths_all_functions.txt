[code]
/* $Id: jfdctint.c,v 1.2 2005/04/04 11:34:58 csg Exp $ */



/*************************************************************************/

/*                                                                       */

/*   SNU-RT Benchmark Suite for Worst Case Timing Analysis               */

/*   =====================================================               */

/*                              Collected and Modified by S.-S. Lim      */

/*                                           sslim@archi.snu.ac.kr       */

/*                                         Real-Time Research Group      */

/*                                        Seoul National University      */

/*                                                                       */

/*                                                                       */

/*        < Features > - restrictions for our experimental environment   */

/*                                                                       */

/*          1. Completely structured.                                    */

/*               - There are no unconditional jumps.                     */

/*               - There are no exit from loop bodies.                   */

/*                 (There are no 'break' or 'return' in loop bodies)     */

/*          2. No 'switch' statements.                                   */

/*          3. No 'do..while' statements.                                */

/*          4. Expressions are restricted.                               */

/*               - There are no multiple expressions joined by 'or',     */

/*                'and' operations.                                      */

/*          5. No library calls.                                         */

/*               - All the functions needed are implemented in the       */

/*                 source file.                                          */

/*                                                                       */

/*                                                                       */

/*************************************************************************/

/*                                                                       */

/*  FILE: jfdctint.c                                                     */

/*  SOURCE : Thomas G. Lane,  Public domain JPEG source code.            */

/*           Modified by Steven Li at Princeton University.              */

/*                                                                       */

/*  DESCRIPTION :                                                        */

/*                                                                       */

/*     JPEG slow-but-accurate integer implementation of the forward      */

/*     DCT (Discrete Cosine Transform).                                  */

/*                                                                       */

/*  REMARK :                                                             */

/*                                                                       */

/*  EXECUTION TIME :                                                     */

/*                                                                       */

/*                                                                       */

/*************************************************************************/





/**********************************************************************

    Functions to be timed

***********************************************************************/



/* This definitions are added by Steven Li so as to bypass the header

   files.

   */

#define DCT_ISLOW_SUPPORTED

#define DCTSIZE 8

#define BITS_IN_JSAMPLE 8

#define MULTIPLY16C16(var,const)  ((var) * (const))

#define DCTELEM int

#define INT32   int

#define GLOBAL

#define RIGHT_SHIFT(x,shft)	((x) >> (shft))

#define ONE	((INT32) 1)

#define DESCALE(x,n)  RIGHT_SHIFT((x) + (ONE << ((n)-1)), n)

#define SHIFT_TEMPS





/*

 * jfdctint.c

 *

 * Copyright (C) 1991-1994, Thomas G. Lane.

 * This file is part of the Independent JPEG Group's software.

 * For conditions of distribution and use, see the accompanying README file.

 *

 * This file contains a slow-but-accurate integer implementation of the

 * forward DCT (Discrete Cosine Transform).

 *

 * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT

 * on each column.  Direct algorithms are also available, but they are

 * much more complex and seem not to be any faster when reduced to code.

 *

 * This implementation is based on an algorithm described in

 *   C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT

 *   Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,

 *   Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.

 * The primary algorithm described there uses 11 multiplies and 29 adds.

 * We use their alternate method with 12 multiplies and 32 adds.

 * The advantage of this method is that no data path contains more than one

 * multiplication; this allows a very simple and accurate implementation in

 * scaled fixed-point arithmetic, with a minimal number of shifts.

 */



#define JPEG_INTERNALS



#ifdef DCT_ISLOW_SUPPORTED





/*

 * This module is specialized to the case DCTSIZE = 8.

 */



#if DCTSIZE != 8

  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */

#endif





/*

 * The poop on this scaling stuff is as follows:

 *

 * Each 1-D DCT step produces outputs which are a factor of sqrt(N)

 * larger than the true DCT outputs.  The final outputs are therefore

 * a factor of N larger than desired; since N=8 this can be cured by

 * a simple right shift at the end of the algorithm.  The advantage of

 * this arrangement is that we save two multiplications per 1-D DCT,

 * because the y0 and y4 outputs need not be divided by sqrt(N).

 * In the IJG code, this factor of 8 is removed by the quantization step

 * (in jcdctmgr.c), NOT in this module.

 *

 * We have to do addition and subtraction of the integer inputs, which

 * is no problem, and multiplication by fractional constants, which is

 * a problem to do in integer arithmetic.  We multiply all the constants

 * by CONST_SCALE and convert them to integer constants (thus retaining

 * CONST_BITS bits of precision in the constants).  After doing a

 * multiplication we have to divide the product by CONST_SCALE, with proper

 * rounding, to produce the correct output.  This division can be done

 * cheaply as a right shift of CONST_BITS bits.  We postpone shifting

 * as long as possible so that partial sums can be added together with

 * full fractional precision.

 *

 * The outputs of the first pass are scaled up by PASS1_BITS bits so that

 * they are represented to better-than-integral precision.  These outputs

 * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word

 * with the recommended scaling.  (For 12-bit sample data, the intermediate

 * array is INT32 anyway.)

 *

 * To avoid overflow of the 32-bit intermediate results in pass 2, we must

 * have BITS_IN_JSAMPLE + CONST_BITS + PASS1_BITS <= 26.  Error analysis

 * shows that the values given below are the most effective.

 */



#if BITS_IN_JSAMPLE == 8

#define CONST_BITS  13

#define PASS1_BITS  2

#else

#define CONST_BITS  13

#define PASS1_BITS  1		/* lose a little precision to avoid overflow */

#endif



/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus

 * causing a lot of useless floating-point operations at run time.

 * To get around this we use the following pre-calculated constants.

 * If you change CONST_BITS you may want to add appropriate values.

 * (With a reasonable C compiler, you can just rely on the FIX() macro...)

 */



#if CONST_BITS == 13

#define FIX_0_298631336  ((INT32)  2446)	/* FIX(0.298631336) */

#define FIX_0_390180644  ((INT32)  3196)	/* FIX(0.390180644) */

#define FIX_0_541196100  ((INT32)  4433)	/* FIX(0.541196100) */

#define FIX_0_765366865  ((INT32)  6270)	/* FIX(0.765366865) */

#define FIX_0_899976223  ((INT32)  7373)	/* FIX(0.899976223) */

#define FIX_1_175875602  ((INT32)  9633)	/* FIX(1.175875602) */

#define FIX_1_501321110  ((INT32)  12299)	/* FIX(1.501321110) */

#define FIX_1_847759065  ((INT32)  15137)	/* FIX(1.847759065) */

#define FIX_1_961570560  ((INT32)  16069)	/* FIX(1.961570560) */

#define FIX_2_053119869  ((INT32)  16819)	/* FIX(2.053119869) */

#define FIX_2_562915447  ((INT32)  20995)	/* FIX(2.562915447) */

#define FIX_3_072711026  ((INT32)  25172)	/* FIX(3.072711026) */

#else

#define FIX_0_298631336  FIX(0.298631336)

#define FIX_0_390180644  FIX(0.390180644)

#define FIX_0_541196100  FIX(0.541196100)

#define FIX_0_765366865  FIX(0.765366865)

#define FIX_0_899976223  FIX(0.899976223)

#define FIX_1_175875602  FIX(1.175875602)

#define FIX_1_501321110  FIX(1.501321110)

#define FIX_1_847759065  FIX(1.847759065)

#define FIX_1_961570560  FIX(1.961570560)

#define FIX_2_053119869  FIX(2.053119869)

#define FIX_2_562915447  FIX(2.562915447)

#define FIX_3_072711026  FIX(3.072711026)

#endif





/* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.

 * For 8-bit samples with the recommended scaling, all the variable

 * and constant values involved are no more than 16 bits wide, so a

 * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.

 * For 12-bit samples, a full 32-bit multiplication will be needed.

 */



#if BITS_IN_JSAMPLE == 8

#define MULTIPLY(var,const)  MULTIPLY16C16(var,const)

#else

#define MULTIPLY(var,const)  ((var) * (const))

#endif



DCTELEM data[64];



/*

 * Perform the forward DCT on one block of samples.

 */



GLOBAL void

jpeg_fdct_islow ()

{

  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;

  INT32 tmp10, tmp11, tmp12, tmp13;

  INT32 z1, z2, z3, z4, z5;

  DCTELEM *dataptr;

  int ctr;

  SHIFT_TEMPS



  /* Pass 1: process rows. */

  /* Note results are scaled up by sqrt(8) compared to a true DCT; */

  /* furthermore, we scale the results by 2**PASS1_BITS. */



  dataptr = data;

  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {

    tmp0 = dataptr[0] + dataptr[7];

    tmp7 = dataptr[0] - dataptr[7];

    tmp1 = dataptr[1] + dataptr[6];

    tmp6 = dataptr[1] - dataptr[6];

    tmp2 = dataptr[2] + dataptr[5];

    tmp5 = dataptr[2] - dataptr[5];

    tmp3 = dataptr[3] + dataptr[4];

    tmp4 = dataptr[3] - dataptr[4];



    /* Even part per LL&M figure 1 --- note that published figure is faulty;

     * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".

     */



    tmp10 = tmp0 + tmp3;

    tmp13 = tmp0 - tmp3;

    tmp11 = tmp1 + tmp2;

    tmp12 = tmp1 - tmp2;



    dataptr[0] = (DCTELEM) ((tmp10 + tmp11) << PASS1_BITS);

    dataptr[4] = (DCTELEM) ((tmp10 - tmp11) << PASS1_BITS);



    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);

    dataptr[2] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),

				   CONST_BITS-PASS1_BITS);

    dataptr[6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),

				   CONST_BITS-PASS1_BITS);



    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).

     * cK represents cos(K*pi/16).

     * i0..i3 in the paper are tmp4..tmp7 here.

     */



    z1 = tmp4 + tmp7;

    z2 = tmp5 + tmp6;

    z3 = tmp4 + tmp6;

    z4 = tmp5 + tmp7;

    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */



    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */

    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */

    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */

    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */

    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */

    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */

    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */

    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */



    z3 += z5;

    z4 += z5;



    dataptr[7] = (DCTELEM) DESCALE(tmp4 + z1 + z3, CONST_BITS-PASS1_BITS);

    dataptr[5] = (DCTELEM) DESCALE(tmp5 + z2 + z4, CONST_BITS-PASS1_BITS);

    dataptr[3] = (DCTELEM) DESCALE(tmp6 + z2 + z3, CONST_BITS-PASS1_BITS);

    dataptr[1] = (DCTELEM) DESCALE(tmp7 + z1 + z4, CONST_BITS-PASS1_BITS);



    dataptr += DCTSIZE;		/* advance pointer to next row */

  }



  /* Pass 2: process columns.

   * We remove the PASS1_BITS scaling, but leave the results scaled up

   * by an overall factor of 8.

   */



  dataptr = data;

  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {

    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*7];

    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];

    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*6];

    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];

    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*5];

    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];

    tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*4];

    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];



    /* Even part per LL&M figure 1 --- note that published figure is faulty;

     * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".

     */



    tmp10 = tmp0 + tmp3;

    tmp13 = tmp0 - tmp3;

    tmp11 = tmp1 + tmp2;

    tmp12 = tmp1 - tmp2;



    dataptr[DCTSIZE*0] = (DCTELEM) DESCALE(tmp10 + tmp11, PASS1_BITS);

    dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS);



    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);

    dataptr[DCTSIZE*2] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),

					   CONST_BITS+PASS1_BITS);

    dataptr[DCTSIZE*6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),

					   CONST_BITS+PASS1_BITS);



    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).

     * cK represents cos(K*pi/16).

     * i0..i3 in the paper are tmp4..tmp7 here.

     */



    z1 = tmp4 + tmp7;

    z2 = tmp5 + tmp6;

    z3 = tmp4 + tmp6;

    z4 = tmp5 + tmp7;

    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */



    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */

    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */

    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */

    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */

    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */

    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */

    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */

    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */



    z3 += z5;

    z4 += z5;



    dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(tmp4 + z1 + z3,

					   CONST_BITS+PASS1_BITS);

    dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp5 + z2 + z4,

					   CONST_BITS+PASS1_BITS);

    dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(tmp6 + z2 + z3,

					   CONST_BITS+PASS1_BITS);

    dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp7 + z1 + z4,

					   CONST_BITS+PASS1_BITS);



    dataptr++;			/* advance pointer to next column */

  }

}



#endif /* DCT_ISLOW_SUPPORTED */











/* Main function

   Time to function execution time using logic analyzer,

   which measures the OFF time of a LED on board.



   The switching latency, including the function call/return time,

   is measured to be equal to 1.1us (22 clock cycles).

*/

void main(void)

{

  int i, seed;



  /* Worst case settings */

  /* Set array to random values */

  seed = 1;

  for (i = 0; i < 64; i++) {

    seed = ((seed * 133) + 81) % 65535;

    data[i] = seed;

  }



  jpeg_fdct_islow();

}

---

---
[cdfg jpeg_fdct_islow]

```dot
digraph jpeg_fdct_islow {
    rankdir=TB;
    node [shape=circle];
    
    1 [label="1", xlabel="Def: data, CONST_BITS, DCTSIZE"];
    2 [label="2", xlabel="Def: z\nUse: data"];
    3 [label="3", xlabel="P-Use: (z < 0)"];
    4 [label="4", xlabel="P-Use: (qBlockRows <= nBlocks)"];
    5 [label="5", xlabel="Def: n, qBlockRows\nUse: data"];
    6 [label="6", xlabel="Def: blockRow\nUse: qBlockRows"];
    7 [label="7", xlabel="P-Use: (blockRow < DCTSIZE)"];
    8 [label="8", xlabel="Def: tmp\nUse: z"];
    9 [label="9", xlabel="P-Use: (tmp >= 0)"];
    10 [label="10", xlabel="Def: data_block[...]\nUse: tmp"];
    11 [label="11", xlabel="Def: qBlock\nUse: data_block"];
    12 [label="12", xlabel="P-Use: (qBlock <= nBlocks)"];
    13 [label="13", xlabel="Def: block\nUse: qBlock"];
    14 [label="14", xlabel="P-Use: (block < DCTSIZE)"];
    15 [label="15", xlabel="Def: data_block[...]\nUse: z"];
    16 [label="16", xlabel="Def: data\nUse: data_block, blockRow"];
    
    1 -> 2;
    2 -> 3 [label="True\n(z < 0)"];
    2 -> 5 [label="False"];
    3 -> 4;
    4 -> 5;
    5 -> 6;
    6 -> 7;
    7 -> 8 [label="True"];
    7 -> 11 [label="False"];
    8 -> 9 [label="tmp >= 0"];
    9 -> 10;
    10 -> 12;
    10 -> 15 [label="qBlock <= nBlocks"];
    11 -> 13 [label="(block < DCTSIZE)"];
    13 -> 14;
    14 -> 16;
    15 -> 16;
    
    16 [shape=doublecircle];
}
```

<codigos - jpeg_fdct_islow>
Node 1:
static const intCONST_BITS = ...;
static const intDCTSIZE = ...;

int data[DCTSIZE][DCTSIZE];

...
---
Node 2:
for (i = 0; i < n; i++) {
    z[i] = data[i];
}
...
</codigos>
---

---
[analise infeasible_paths jpeg_fdct_islow]

```markdown
Nenhum caminho inviável foi identificado.
```
---

---
[cdfg main]

To generate a CDFG for the given main function, we'll represent each significant step as a node, capturing both control and data flow.

**Nodes:**

1. **Node 1**: Declare `int i, seed;`
   - Def: `i`, `seed`
   - Use: None
   - Next node: Node2

2. **Node2**: Assign `seed = 1;`
   - Def: `seed`
   - Use: None
   - Next node: Node3

3. **Node3**: Enter for loop, initialize `i = 0;`
   - Def: `i`
   - Use: None
   - Next node: Node4

4. **Node4**: Check condition `if (i < 64)`
   - Use: `i`
   - If true → Node5
   - If false → exit loop, proceed to Node8

5. **Node5**: Update `seed = ((seed * 133) + 81) % 65535;`
   - Use: `seed`
   - Def: `seed`
   - Next node: Node6

6. **Node6**: Assign `data[i] = seed;`
   - Use: `i`, `seed`
   - Def: `data[i]`
   - Next node: Node7

7. **Node7**: Increment `i` (`i++`)
   - Use: `i`
   - Def: `i`
   - Next node: Node4 (back to condition check)

8. **Node8**: Call `jpeg_fdct_islow();`
   - Use: None
   - Def: None

**Control Flow Edges:**

- 1 → 2 → 3 → 4
- 4 → 5 (if true)
- 5 →6 →7 →4 (loop back)
- 4 →8 (if false)

**Data Flow Dependencies:**

- Node2 defines `seed` used in Node5.
- Node3 defines `i` used in Nodes4,6,7.
- Each iteration:
   - Node5 uses previous `seed`.
   - Node6 uses updated `i` and `seed`, defines `data[i]`.
   - Node7 updates `i`.

The CDFG visually connects these nodes with edges showing both control (solid arrows) and data flow (dashed arrows), capturing all variable dependencies and control structures.
---

---
[analise infeasible_paths main]

# Caminhos Inviáveis Identificados

Nenhum caminho inviável foi identificado.

```markdown
Nenhum caminho inviável foi identificado.
```

**Motivo:**  
- Todas as variáveis são inicializadas adequadamente.  
- O loop é garantido para terminar após 64 iterações.  
- Não há condições ou dependências de dados que possam levar a estados contraditórios.
---

---
**Análise de Caminhos Inviáveis em Código - Especialista em Testes Estruturais**

**Instruções de Entrada:**  
Forneça:  
1. O código-fonte a ser analisado  
2. Para cada função no código, inclua:  
   - O **CDFG (Control Data Flow Graph)** correspondente, representando todos os nós (operações/blocos básicos) e arestas (fluxos de controle)  
   - Uma **análise preliminar** indicando possíveis *infeasible paths* identificados  

---

**Processo de Análise (Executado Automaticamente):**  

**1. Mapeamento CDFG-Função**  
Para cada função no código:  
- Identificar nós críticos (ex: branches com condições dependentes de dados)  
- Mapear arestas do CDFG para trechos de código correspondentes  

**2. Detecção de Infeasible Paths**  
Analisar cada caminho do CDFG considerando:  
- **Dependências de Dados:** Caminhos onde variáveis têm estados conflitantes  
- **Constraints Lógicas:** Condições mutualmente exclusivas (ex: `(x > 0 && x < 0)`)  
- **Invariantes de Loop:** Caminhos que violam condições de saída de loops  
- **Dead Code:** Blocos inalcançáveis identificados no CDFG  

**3. Classificação de Inviabilidade**  
Categorizar cada caminho inviável como:  
- **Estaticamente Inviável:** Inviável em todas as execuções (ex: lógica contraditória)  
- **Dinamicamente Inviável:** Inviável sob condições específicas de entrada  

**4. Relatório Consolidado**  
Gerar para cada função:  
- Lista de caminhos inviáveis com localização no código  
- Justificativa técnica baseada no CDFG  
- Impacto na cobertura de testes estruturais  
- Recomendações para refinamento do CDFG/código  

---

**Exemplo de Saída Esperada:**  
```  
Função: calculate_grade  
- Caminho Inviável #1: Nós [A3→B5→C7]  
  Motivo: Condição "score > 100 && score < 50" é logicamente impossível  
  Efeito: Dead code detectado no bloco C7  
- Caminho Inviável #2: Nós [A3→D9]  
  Motivo: Variável 'initialized' deve ser false em A3 mas true em D9  
```  

**Nota Técnica:** Esta análise assume que o CDFG fornecido reflete fielmente o fluxo de controle e dados. Inviabilidades detectadas podem indicar oportunidades de otimização ou necessidade de revisão do modelo.
---
